{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/images/internal_storage_java_hashmap.jpg","path":"images/internal_storage_java_hashmap.jpg","modified":1,"renderable":0},{"_id":"source/images/日志收集架构图.png","path":"images/日志收集架构图.png","modified":1,"renderable":0},{"_id":"source/images/知识体系总览.pdf","path":"images/知识体系总览.pdf","modified":1,"renderable":0},{"_id":"source/images/消息总线.jpg","path":"images/消息总线.jpg","modified":1,"renderable":0},{"_id":"source/images/企业类型.png","path":"images/企业类型.png","modified":1,"renderable":0},{"_id":"source/images/怎样才能生活得更好.pdf","path":"images/怎样才能生活得更好.pdf","modified":1,"renderable":0},{"_id":"source/images/目标.jpeg","path":"images/目标.jpeg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/422.jpg","path":"images/422.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/图解HTTPS.png","path":"images/图解HTTPS.png","modified":1,"renderable":0},{"_id":"source/images/写时复制B+树.png","path":"images/写时复制B+树.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"c3bb95eb12e6d77fd9589f714adf0b88f2676842","modified":1523073276000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1523073276000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1523073276000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1523073276000},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1523073276000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1523073276000},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1523073276000},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1523073276000},{"_id":"themes/next/bower.json","hash":"b133dd92c7a825745a3b74474c2d738d9fd8ff07","modified":1523073276000},{"_id":"themes/next/crowdin.yml","hash":"fe22a450cc1272b7ac5476e6b33a999f8b8a2034","modified":1523073276000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1523073276000},{"_id":"themes/next/README.md","hash":"d3f80d4eeff0e1b0ef2d4c28ed908e1459fb75b8","modified":1523073276000},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1523073276000},{"_id":"themes/next/_config.yml","hash":"fdb3a0119fd2878400841f99441d639f5fe4c280","modified":1523068119000},{"_id":"themes/next/package.json","hash":"77f15fd8e1bf54fe9e04513e38a70823225256cc","modified":1523073276000},{"_id":"source/_posts/HTTP_HTTPS_Token.md","hash":"d85e18bbe64a3a3504f06575af1f19616f6cbe1b","modified":1523073276000},{"_id":"source/_posts/knowledge-hierarchy.md","hash":"f351310f143de24606bc407bd3257ccd1cca43a1","modified":1523073276000},{"_id":"source/_posts/redisInAction.md","hash":"16c3eba21c94eb45000eabc19b38c416a09b5e7c","modified":1523073276000},{"_id":"source/_posts/operate-family-like-a-company.md","hash":"f8934eef2ad2d38632661e14282f20e3ee64531c","modified":1523073276000},{"_id":"source/_posts/mq-why-and-where-to-use-it.md","hash":"6b95a0ccd15cd361c999842c346d8c8ffab545eb","modified":1523073276000},{"_id":"source/_posts/how-does-a-hashmap-work-in-java.md","hash":"62f1b7919bce1827f702a13c3ca5c8e5258b06a8","modified":1523073276000},{"_id":"source/_posts/rocketMQ-2-installation-and-simple-usages.md","hash":"63c827583861e8d7be999b941ac4e62c65b32801","modified":1523073276000},{"_id":"source/_posts/rocketMq-in-action.md","hash":"1d51a1789d49415b48c1d5f9d57c31934ab4c207","modified":1523073276000},{"_id":"source/_posts/rocketMQ-1-concepts.md","hash":"608016cac00e198eee5e789b4910376e3ac09d21","modified":1523073276000},{"_id":"source/categories/index.md","hash":"32459702eeff7bab8f54b6c54da9a43780df1385","modified":1523073276000},{"_id":"source/_posts/怎样才能生活得更好-奇特的一生读书笔记.md","hash":"adccd05779f20c3e638dbb4ae459f0194f57b547","modified":1523073276000},{"_id":"source/_posts/大规模分布式存储系统-原理解析与架构实战.md","hash":"f6b9fdbdf94401a136db41f64ea49a932376e065","modified":1523073276000},{"_id":"source/images/internal_storage_java_hashmap.jpg","hash":"f6a4065d89ec49d8b91070531238cac0920b9232","modified":1523073276000},{"_id":"source/images/日志收集架构图.png","hash":"be560f12df555a8757a7778f2661507b60223a48","modified":1523073276000},{"_id":"source/images/知识体系总览.pdf","hash":"3e08b8a7db950b4719b107248fa9a2d6aa893180","modified":1523073276000},{"_id":"source/tags/index.md","hash":"e02acda2f488ab71988934d0e2e0806759f5d2b7","modified":1523073276000},{"_id":"source/images/消息总线.jpg","hash":"bb41092750bd934c261d04fb5a6241fefeec0c95","modified":1523073276000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1523073276000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"17f75f0de0d88e6b5b4bee639b03c364eb1233c5","modified":1523073276000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1523073276000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1523073276000},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1523073276000},{"_id":"themes/next/docs/MATH.md","hash":"d047b8a3d9aa49b478a33e5a326195d460cb4589","modified":1523073276000},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1523073276000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1523073276000},{"_id":"themes/next/languages/_en.yml","hash":"a680b1adb920b5760a84b1656bee5d2aaedd5689","modified":1523073276000},{"_id":"themes/next/languages/bg.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/ar.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/bn.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/cs.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/de.yml","hash":"27b8f7f1b0467466839f317986d195367c5db8b8","modified":1523073276000},{"_id":"themes/next/languages/da.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/el.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/es.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/et.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/fa.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/fi.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/fr.yml","hash":"15999d4301ea5493e4a9bbbe9a282b4cd0f98d84","modified":1523073276000},{"_id":"themes/next/languages/hu.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/he.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/hr.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/hi.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/id.yml","hash":"109cdfd760ab2ecfd00d067ff1373d7ceaa00d33","modified":1523073276000},{"_id":"themes/next/languages/jv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/ja.yml","hash":"60239d1d923b77eed2b4e9ebea113457b95fffd9","modified":1523073276000},{"_id":"themes/next/languages/it.yml","hash":"404af1d8180972d98afbc7ac424bde2908ede9f4","modified":1523073276000},{"_id":"themes/next/languages/ko.yml","hash":"2aacd56326266c03031515a0e01f3fbba89aff85","modified":1523073276000},{"_id":"themes/next/languages/ms.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/lv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/lt.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/pl.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/nl.yml","hash":"159dab3d37d642955d2d7e6bf719a76481c5e6d3","modified":1523073276000},{"_id":"themes/next/languages/no.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/pa.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/pt.yml","hash":"912444e12419f3461d9da49e80674f73e0664158","modified":1523073276000},{"_id":"themes/next/languages/pt-BR.yml","hash":"f038084097e12fae57db70abf695eeeaf69710d8","modified":1523073276000},{"_id":"themes/next/languages/ro.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/ru.yml","hash":"da1668689c08ccc7115e4e2cd1721579c9d5160b","modified":1523073276000},{"_id":"themes/next/languages/sl.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/sr.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/sv.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/th.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/tr.yml","hash":"f61c0c6a23228368721b9338bf5c14d94be40d00","modified":1523073276000},{"_id":"themes/next/languages/uk.yml","hash":"cb7fa9dfb84596903a4fb5ce5ae40e5db4106c88","modified":1523073276000},{"_id":"themes/next/languages/vi.yml","hash":"7353c4b45a3708c3707d11d0def38606b3e18447","modified":1523073276000},{"_id":"themes/next/languages/zh-CN.yml","hash":"fa86f88d55086b6e319fadbc5ba2b48101abcd39","modified":1523073276000},{"_id":"themes/next/languages/zh-HK.yml","hash":"3388dcf8d04093e1ccff826be91cf4b35453ea80","modified":1523073276000},{"_id":"themes/next/languages/zh-TW.yml","hash":"dec9c71a3b4935fbbcbd4bc0e65a99b98b68f152","modified":1523073276000},{"_id":"themes/next/layout/_layout.swig","hash":"5803acd1f338db83a3b8d99eebbf163083e02520","modified":1523073276000},{"_id":"themes/next/layout/archive.swig","hash":"833a2213d31be45a12b8e4e5e609073978bd251b","modified":1523073276000},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1523073276000},{"_id":"themes/next/layout/index.swig","hash":"7229e88f077be11d6ae5978db0254edad942744b","modified":1523073276000},{"_id":"themes/next/layout/page.swig","hash":"3f9b2444f12251727ebbc28159f02e9e9489742e","modified":1523073276000},{"_id":"themes/next/scripts/merge-configs.js","hash":"ca9845dc76f5710b4c6fba5fe25ff0d2fcf0adaa","modified":1523073276000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1523073276000},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1523073276000},{"_id":"themes/next/layout/post.swig","hash":"8e2d079b46076996cc9343213d5bf7da8178d32d","modified":1523073276000},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1523073276000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1523073276000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1523073276000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1523073276000},{"_id":"source/images/企业类型.png","hash":"2d3cef983d355b1391bf1e6217ed5a0cc5611753","modified":1523073276000},{"_id":"source/images/怎样才能生活得更好.pdf","hash":"a83a586a240b70b9fc967b06dcb58af8965e87fe","modified":1523073276000},{"_id":"source/images/目标.jpeg","hash":"122adbc29aae20702502cf1819fe7c4706e234fb","modified":1523073276000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1523073276000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1523073276000},{"_id":"themes/next/docs/ru/README.md","hash":"389a29cf8ac8f1a58e3eff7004cf15449492484f","modified":1523073276000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"f904316934d811818804df21b9a7ec5006b2cf02","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"59811e21ba41420b7093e210d6a584aac9fc1a9b","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"155f5fcf2daf805fed8ade4dc53e2b16d6ca6068","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"1c7df019737656fdfd8d124c7c045a64ac8a2a8d","modified":1523073276000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1523073276000},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1523073276000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523073276000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1523073276000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523073276000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"464082e431ea5b06df782d5f312ee25be9e5f169","modified":1523073276000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"aa620c582143f43ba1cb1a5e59240041a911185b","modified":1523073276000},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1523073276000},{"_id":"themes/next/layout/_macro/post.swig","hash":"dc5e3b6f38d240928ae0e6cc0d9d51fafcdac50d","modified":1523073276000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"fea45ab314b9ea23edab25c2b8620f909d856b1d","modified":1523073276000},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1523073276000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1523073276000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"8aa22cec1941b85ba4b78740fc8f1b96e9ae28c0","modified":1523073276000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"355ddd5b8af696f7bffb183addd7e84c0a4e2123","modified":1523073276000},{"_id":"themes/next/layout/_partials/header.swig","hash":"6bdae92508fb5009b023386341f3b161a4ac6c70","modified":1523073276000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1523073276000},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1523073276000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1523073276000},{"_id":"themes/next/layout/_partials/sub-menu.swig","hash":"9783a9569fe8344ed287013156e52ca1b0a25544","modified":1523073276000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1523073276000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1523073276000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1523073276000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1523073276000},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1523073276000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1523073276000},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1523073276000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1523073276000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1523073276000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1523073276000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1523073276000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1523073276000},{"_id":"themes/next/scripts/tags/button.js","hash":"5a61c2da25970a4981fbd65f4a57c5e85db4dcda","modified":1523073276000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"db70a841e7c1708f95ca97b44413b526b267fa9b","modified":1523073276000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"2b3a4dc15dea33972c0b6d46a1483dabbf06fb5b","modified":1523073276000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a98fc19a90924f2368e1982f8c449cbc09df8439","modified":1523073276000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1b97b1b5364945b8ab3e50813bef84273055234f","modified":1523073276000},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"b7600f6b868d8f4f7032126242d9738cd1e6ad71","modified":1523073276000},{"_id":"themes/next/scripts/tags/label.js","hash":"621004f2836040b12c4e8fef77e62cf22c561297","modified":1523073276000},{"_id":"themes/next/scripts/tags/note.js","hash":"4975d4433e11161b2e9a5744b7287c2d667b3c76","modified":1523073276000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1523073276000},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1523073276000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1523073276000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1523073276000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523073276000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523073276000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523073276000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523073276000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523073276000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523073276000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523073276000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523073276000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523073276000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1523073276000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1523073276000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1523073276000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523073276000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"61a27b59869591e853891e64487cf125c262ef29","modified":1523073276000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523073276000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523073276000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523073276000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523073276000},{"_id":"themes/next/source/images/422.jpg","hash":"29a1ef1d067c7e88a6413cd1355db3eccc57efa8","modified":1523073276000},{"_id":"themes/next/layout/_macro/menu/menu-badge-1.swig","hash":"7ffc5c159ab566805ceda6b8c7a4149a7e296116","modified":1523073276000},{"_id":"themes/next/layout/_macro/menu/menu-badge-2.swig","hash":"7b96a0e6079e845573338523cea4437817a4b1e1","modified":1523073276000},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"6a04cd1ef9ebac103d86b61505fa9b0f26268fdc","modified":1523073276000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1523073276000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"b8e93a67b4e09560a6bf6c377a83032eb89f418f","modified":1523073276000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"9f7aa33a620aea6ede1fb907b61fd071c018c525","modified":1523073276000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1523073276000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1523073276000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1523073276000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1523073276000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1523073276000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1523073276000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1523073276000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1523073276000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1523073276000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"4fa826f2e02f25b2354668ec2e42fa42ee13e6ec","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1523073276000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"2fbee33a4ccd7c8217c73e85a9a1488170e05629","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1523073276000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1523073276000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1523073276000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1523073276000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"011ae6303afacddabc4ddf570fe3dd227569cd4f","modified":1523073276000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1523073276000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1523073276000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1523073276000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1523073276000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"47136b259b0c5e22698652e36ef5cdd4d14b0f2c","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1523073276000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1523073276000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1523073276000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1523073276000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"32392d213f5d05bc26b2dc452f2fc6fea9d44f6d","modified":1523073276000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"001defcd6cb5d82abe0f92f81b6ca2b1cd5b49ba","modified":1523073276000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1523073276000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1523073276000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523073276000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1523073276000},{"_id":"themes/next/source/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1523073276000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1523073276000},{"_id":"themes/next/source/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1523073276000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1523073276000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523073276000},{"_id":"themes/next/source/js/src/utils.js","hash":"bb67eb5b5f301a92503c81b1f8edd2a4d1fcc879","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/README.md","hash":"a40db80eb6386b085ff810fd3e302f12e76b8df7","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1523073276000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523073276000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523073276000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523073276000},{"_id":"source/images/图解HTTPS.png","hash":"bb5ad482cd4830f6b5cf4f05bea2f5dce1dc01f1","modified":1523073276000},{"_id":"source/images/写时复制B+树.png","hash":"59317e4c43c77962bc40e1cc189f36742ce50f9d","modified":1523073276000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523073276000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1523073276000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1523073276000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1523073276000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"a863f2c8bae1fbccdc181a5d178b808cd80c5b5e","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1523073276000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1523073276000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523073276000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523073276000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"abe8b62d3a4257d5699adb182f6c06f9f2618d70","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"381fcdefb6493978d18618afdd7322e0a39decdc","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"5d15cc8bbefe44c77a9b9f96bf04a6033a4b35b8","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"057f4b720a496c30afb91990589e6733356e71c8","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1523073276000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1523073276000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1523073276000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1523073276000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523073276000},{"_id":"public/baidu_urls.txt","hash":"d3fa6663544ecb5d33a0e271ab33747a459fbe54","modified":1523076413502},{"_id":"public/baidusitemap.xml","hash":"4cf6aaa2f77addc999273fceafc9dca2c0c7310f","modified":1523076413518},{"_id":"public/search.xml","hash":"e521f560f11f8134a0b51b11e04db13eb30929d4","modified":1523076413518},{"_id":"public/sitemap.xml","hash":"e0794da2b14888896ecf6bcff3ab84378f45f7e1","modified":1523076413518},{"_id":"public/categories/index.html","hash":"3e2c3ab45a4a9e6c25696a23785099d461881473","modified":1523076413863},{"_id":"public/tags/index.html","hash":"a9dfaf2cb122fbc56f74d79edec1d168a90db43d","modified":1523076413866},{"_id":"public/怎样才能生活得更好-奇特的一生读书笔记.html","hash":"af4236ca7a175afaf6d9ca8b6966fa62daef9c71","modified":1523076413866},{"_id":"public/knowledge-hierarchy.html","hash":"b8f2ba9148915fd9c7beba30b5b061851796102a","modified":1523076413866},{"_id":"public/rocketMq-in-action.html","hash":"9114061d767a47df14a49e7255cad5b6059e1d95","modified":1523076413868},{"_id":"public/operate-family-like-a-company.html","hash":"4e8686ec77e0dc737becf2086a3baec9dd9eb246","modified":1523076413868},{"_id":"public/how-does-a-hashmap-work-in-java.html","hash":"b58711cfc6f35d0b5f444526114eecb7d0db96a9","modified":1523076413868},{"_id":"public/HTTP_HTTPS_Token.html","hash":"1ac7a58c1f3590e25c8299c37a1ebabe299d7cea","modified":1523076413868},{"_id":"public/redisInAction.html","hash":"1859f3d57487d4e0444f9cd4ee301019073b8fe4","modified":1523076413868},{"_id":"public/rocketMQ-2-installation-and-simple-usages.html","hash":"76ac16b72c67de0410390a5b26ceb205fa174480","modified":1523076413868},{"_id":"public/rocketMQ-1-concepts.html","hash":"f31e2367eeac74f5f81a4529df2e342a4ce8535f","modified":1523076413869},{"_id":"public/mq-why-and-where-to-use-it.html","hash":"1dbfcf3a6128fdf766799beb4766ade7bb95e7d6","modified":1523076413869},{"_id":"public/大规模分布式存储系统-原理解析与架构实战.html","hash":"b318efa483e06d5c1d450deba0da630f7b610211","modified":1523076413869},{"_id":"public/archives/index.html","hash":"3b908c21608fad475448fd31e95182e9d957cef8","modified":1523076413869},{"_id":"public/archives/2018/index.html","hash":"b7df791bdc3037262c66a49d3084b55c8d76f9ce","modified":1523076413869},{"_id":"public/archives/page/2/index.html","hash":"38f08096a59995100015c259b9d2e3ae1aacd51b","modified":1523076413870},{"_id":"public/archives/2018/page/2/index.html","hash":"27934894854a386bcde4ef3d620aa9d1e3287ed7","modified":1523076413870},{"_id":"public/archives/2018/03/index.html","hash":"7e816b971dda6190b423645d3146c8246895d3c7","modified":1523076413870},{"_id":"public/categories/Web/index.html","hash":"9d92cccd1bdb9f0e953e258a3bc3922c92f7d468","modified":1523076413870},{"_id":"public/archives/2018/04/index.html","hash":"f61505075e0160a054d9bf9f9e9e2b76e6bb753f","modified":1523076413870},{"_id":"public/categories/知识体系/index.html","hash":"17bba3a1445b1c7696c57a2238f471b5b0142445","modified":1523076413870},{"_id":"public/categories/BetterLife/index.html","hash":"53b6e8146f65ac6d33258c1974e3002da85df3cf","modified":1523076413870},{"_id":"public/categories/readNote/index.html","hash":"839e3a3c552ae931fa2c28883b9bc381d5fd218f","modified":1523076413871},{"_id":"public/categories/Web/Security/index.html","hash":"04c36b9f962e9a633a101562b0b5d8bec03cb7db","modified":1523076413871},{"_id":"public/categories/MQ/index.html","hash":"faefacd9cce2db8b1e519ebd61e92f5801c64497","modified":1523076413871},{"_id":"public/categories/DataStructure/index.html","hash":"b7de77ce9b20fa4c87ab030cf33cdec544bc4a88","modified":1523076413871},{"_id":"public/categories/Storage/index.html","hash":"69160dabce46e2b8470ddeff828e293608936fff","modified":1523076413871},{"_id":"public/categories/目标驱动/index.html","hash":"6e459a176f00713dce2e45b6e57977ccb4d5a70a","modified":1523076413872},{"_id":"public/categories/MQ/RocketMQ/index.html","hash":"df96e17d35de5e603803ba9dbae53c35e67d1dfd","modified":1523076413872},{"_id":"public/page/2/index.html","hash":"1e1e607d6fce1e4d8836a562ee2cd211d058f582","modified":1523076413872},{"_id":"public/tags/HTTPS/index.html","hash":"14e89a0e04aefb7fb6eead58101f514d04d98c08","modified":1523076413872},{"_id":"public/tags/JWT/index.html","hash":"fc439ac8afd64a4c1d36fd90df337a5b571565fd","modified":1523076413872},{"_id":"public/tags/Redis/index.html","hash":"408a2019531399f0e370064b40a811e943763d01","modified":1523076413872},{"_id":"public/index.html","hash":"13fb47dec93b83842ca8cfb88d1f446a75108922","modified":1523076413872},{"_id":"public/tags/strategy/index.html","hash":"e9bdc7a7121403e6e137316781950a285d27fe2a","modified":1523076413873},{"_id":"public/tags/MQ/index.html","hash":"2bf5905bb199b576c84ea4c7a84b1ae45a761892","modified":1523076413873},{"_id":"public/tags/DataStructure/index.html","hash":"16482d1d1fd13ca74069dd42bfd535f1fd993b41","modified":1523076413873},{"_id":"public/tags/HashMap/index.html","hash":"8278b0a7ed7199afaf2d1a0e19f74a71718d99cf","modified":1523076413880},{"_id":"public/tags/RocketMQ/index.html","hash":"e8ba6eaa72a6d1696b26ef0a4645dd0a32b4f6eb","modified":1523076413880},{"_id":"public/tags/目标驱动/index.html","hash":"9ba323d98a910d863fee41702a7d41eddb8d45d7","modified":1523076413880},{"_id":"public/tags/时间管理/index.html","hash":"fb6cac6ce72d827859b530028e751a8db75dbae1","modified":1523076413881},{"_id":"public/tags/分布式/index.html","hash":"94649282682ab8fe05cb4f11ff2ec715e0bbc974","modified":1523076413881},{"_id":"public/tags/存储/index.html","hash":"77b15d756bb938489dff024b815aab8ec3c5d594","modified":1523076413881},{"_id":"public/robots.txt","hash":"c3bb95eb12e6d77fd9589f714adf0b88f2676842","modified":1523076413881},{"_id":"public/images/internal_storage_java_hashmap.jpg","hash":"f6a4065d89ec49d8b91070531238cac0920b9232","modified":1523076413881},{"_id":"public/images/日志收集架构图.png","hash":"be560f12df555a8757a7778f2661507b60223a48","modified":1523076413881},{"_id":"public/images/知识体系总览.pdf","hash":"3e08b8a7db950b4719b107248fa9a2d6aa893180","modified":1523076413881},{"_id":"public/images/消息总线.jpg","hash":"bb41092750bd934c261d04fb5a6241fefeec0c95","modified":1523076413881},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1523076413881},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1523076413881},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523076413881},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523076413881},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523076413882},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523076413882},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523076413882},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523076413882},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523076413882},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523076413882},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523076413882},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1523076413882},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1523076413882},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1523076413882},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523076413882},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523076413882},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523076413882},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523076413883},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1523076413883},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523076413883},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523076413883},{"_id":"public/images/企业类型.png","hash":"2d3cef983d355b1391bf1e6217ed5a0cc5611753","modified":1523076414526},{"_id":"public/images/怎样才能生活得更好.pdf","hash":"a83a586a240b70b9fc967b06dcb58af8965e87fe","modified":1523076414527},{"_id":"public/images/目标.jpeg","hash":"122adbc29aae20702502cf1819fe7c4706e234fb","modified":1523076414535},{"_id":"public/images/422.jpg","hash":"29a1ef1d067c7e88a6413cd1355db3eccc57efa8","modified":1523076414535},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523076414535},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523076414536},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1523076414637},{"_id":"public/js/src/bootstrap.js","hash":"531cdedd7fbe8cb1dab2e4328774a9f6b15b59da","modified":1523076414637},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523076414637},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1523076414637},{"_id":"public/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1523076414637},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1523076414638},{"_id":"public/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1523076414638},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1523076414638},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523076414638},{"_id":"public/lib/fancybox/README.html","hash":"acfa25ca9b6457a4a70a4b35cf72c9dafc33584e","modified":1523076414638},{"_id":"public/js/src/utils.js","hash":"bb67eb5b5f301a92503c81b1f8edd2a4d1fcc879","modified":1523076414638},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1523076414638},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523076414638},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1523076414639},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"84adea69673c392c1d34a5a316e8e5960aa348b5","modified":1523076414639},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523076414639},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523076414639},{"_id":"public/css/main.css","hash":"f10474c5883cc28e30380af72f30cf0eea167ac3","modified":1523076414639},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523076414639},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523076414639},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523076414640},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"a5913612c237bb7443c6006a386edd775201d423","modified":1523076414640},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1523076414640},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"b85b75426ff7569d54a1f69689895315e80ed85d","modified":1523076414640},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1523076414640},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1523076414640},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"fec45d19179030b8f43ebd0eabc5467892c14136","modified":1523076414641},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523076414641},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523076414641},{"_id":"public/images/图解HTTPS.png","hash":"bb5ad482cd4830f6b5cf4f05bea2f5dce1dc01f1","modified":1523076414735},{"_id":"public/images/写时复制B+树.png","hash":"59317e4c43c77962bc40e1cc189f36742ce50f9d","modified":1523076414735}],"Category":[{"name":"Web","_id":"cjfowdc0800049t9cgwdsxmid"},{"name":"知识体系","_id":"cjfowdc0d00099t9cuwmc2k17"},{"name":"readNote","_id":"cjfowdc0g000d9t9c5zycyng4"},{"name":"BetterLife","_id":"cjfowdc0j000k9t9cibura9y9"},{"name":"Security","parent":"cjfowdc0800049t9cgwdsxmid","_id":"cjfowdc0m000q9t9c5ylejq3x"},{"name":"MQ","_id":"cjfowdc0n000u9t9cpwaiyk2j"},{"name":"DataStructure","_id":"cjfowdc0n000y9t9cfjb5xyln"},{"name":"目标驱动","_id":"cjfowdc0u001c9t9cjuxxxxwu"},{"name":"Storage","_id":"cjfowdc0v001f9t9cyqg06i9v"},{"name":"RocketMQ","parent":"cjfowdc0n000u9t9cpwaiyk2j","_id":"cjfowdc0y001l9t9ctysp4sau"}],"Data":[],"Page":[{"title":"categories","date":"2018-03-14T12:26:17.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-03-14 20:26:17\ntype: categories\n---\n","updated":"2018-04-07T03:54:36.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjfowdc0200019t9c1wf9d5mj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-03-14T12:25:55.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-03-14 20:25:55\ntype: \"tags\"\n---\n","updated":"2018-04-07T03:54:36.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjfowdc0500039t9ck9252tcz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"HTTP、HTTPS、TOKEN的比较 以及 如何选择","date":"2018-03-14T16:00:00.000Z","_content":"### HTTP与HTTPS\n* HTTP的缺点 及 解决方案\n    * 通信使用明文(不加密)，内容可能被窃听\n        > 加密\n    * 不验证通信方的身份，因此有可能遭遇伪装（假的server或client）\n        > 证书 （支持双向验证，但通常只验证服务端.）  \n        > SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份\n    * 无法证明报文的完整性，所以有可能已遭篡改\n        > 基于散列值校验（MD5 / SHA-1）等等的完整性校验方案   \n* HTTPS可以完美解决以上问题\n    >* **HTTP + 加密 + 认证 + 完整性保护 = HTTPS**      \n    >* 请求包可以被截获，但无法解密读取\n    >* 对于HTTPS不做赘述，下面仅附图一张    \n    ![图解HTTPS](/images/图解HTTPS.png)\n<!--more-->\n* 既然HTTPS那么安全可靠，那为何所有的网站不一直使用HTTPS ？\n    * HTTPS比HTTP慢2到100倍\n        * 通信慢\n            > TCP/IP之上还需要SSL通信\n        * 消耗更多的CPU和内存\n            > 客户端和服务端都必须加密解密运算，\n    * 证书的开销\n    \n### HTTP + TOKEN：每次请请求都携带**经过加密且被签名的token**\n* 无状态，可快速验证用户的有效性\n* 加密，防止token被读取篡改\n* 但是第三方可以用截取到的token伪造请求，所以client有被劫持的风险；签名和设置有效期可以解决\n    * GET等非敏感请求\n        * 设置token的有效期\"per session cookies, and per request\" -- 防CSRF\n        * 对于GET，token的签名包含url，确保token和URL是对应的没被更改的 -- 请求顶多被窃听\n            > 例如Get请求时，将parameters加入到签名里，从而防止被篡改；但仍然可以被监听.   \n            POST请求则直接对请求体做MD5计算，将MD5值加入签名.\n    * POST等敏感请求，用HTTPS\n\n### 最终选择\n* 首选HTTPS，如果不用考虑性能和money的话\n    > 认证可随意选择，用户名密码或者简单token\n* HTTP + **token**，请求体、相应体有被监听的风险\n    >1. 提前约定secret、加密方式等   \n    >2. 每次请求都生成唯一的经过加密和签名的token\n    >3. 将md5(requestContent/parameter)作为签名的一部分，避免劫持   \n        上面两点**无法防止伪装**，token可以被窃取，从而有被劫持.可以将md5(requestContent/parameter)作为签名的一部分，避免劫持，顶多有被监听的风险，因为信息不明感，从而可忽略\n* HTTP和HTTPS组合使用\n    * 非敏感信息使用HTTP + **token**的认证方式\n    * 只有在接触敏感信息时才使用HTTPS，如登录\n\n### 反推TOKEN的特性\n* 加密，不可被窃听\n    >1. 加密方式\n    >2. 秘钥\n    >3. 对于API，一般不要求登录，所以用户名和密钥要提前约定好.\n* 签名，可以证明请求没有没篡改\n* 有效期设置功能，防止被窃取后伪造请求；如果是浏览器访问也可以解决CSRF\n    * “**per session cookies, and per request tokens**.”， 可以解决CSRF，但不能解决监听问题。\n    * API不存在CSRF问题，但如果token永不过期，截取到token便可以伪造请求了，所以可以为API的token设置一个长点的过期时间\n    * 所以建议：\n        * API\n            >* 非敏感数据的API过期设的长一些，以免让client频繁请求token\n            >* 敏感数据直接升级用HTTPS\n        * B/S\n            >* HTTPS + per request token\n\n### 案例\n* 去哪儿，HTTP+TOKEN 和 HTTPS\n    * 非敏感数据采用 HTTP + TOKEN\n        ``` java\n        String sign = DigestUtils.md5Hex(DigestUtils.md5Hex(secretKey + appKey) + salt);\n        ```\n        > appKey、secretKey提前约定好   \n        没有有效期，截取sign后可以长期伪装client, 发送重复请求。   \n        没有签名， 伪装client，且可以更改请求\n    \n* 亮哥，HTTP + TOKEN\n    ``` java\n    String sign = md5(userId + timestamps + secret);//per request timestamps\n    ```\n    > server端记录每次请求的timestamps, 当次有效   \n    没有签名， 可以被劫持，从而更改请求\n    \n    \n    \n\n### 伪装问题\n* HTTPS不存在伪装问题\n    >1. 有证书保证server身份，所以无法伪装server   \n    >2. 在用户名密码不被泄露的情况下，能建立起SSL的就是真正的用户\n* HTTP虽然无法彻底解决伪装问题，但是因为token的不可更改不可窃听的属性，伪装被降级成转发监听\n    > 由于token是不可读，不可修改的，所以第三方无法伪造只能引用.   \n    又因为加了有效期，所以第三方最多只能转发监听\n\n#### Client-side/Stateless Sessions (客户端持有的/无状态session)\n* stateless\n    >只保存客户数据  \n    \n* JWT不可被第三方 读取 和 更改\n    >签名 = 不可更改  \n    加密 = 不可读\n    \n#### Cross-Site Request Forgery (CSRF - 跨站请求伪造)\n* 由于同一浏览器进程下 Cookie 可见性，导致用户身份被盗用，完成恶意网站脚本中指定的操作\n\n* 解决方案\n    > “**per session cookies, and per request tokens**.”  \n    \n* 案例一\n    1. 客户端每个request都必须携带 userId + **timestamps** + token\n        > token = md5(userId + secret + timestamps**)，确保信息不被更改\n    2. timestamps只能使用一次\n        > 服务端先校验timestamps是否已经被处理，如果已经处理，拒绝请求\n    3. 服务端根据收到的userId + timestamps和约定好的secret计算token，然后和收到的token进行比较校验\n    ","source":"_posts/HTTP_HTTPS_Token.md","raw":"---\ntitle: HTTP、HTTPS、TOKEN的比较 以及 如何选择\ndate: 2018-03-15\ncategories: \n- Web\n- Security\ntags:\n- HTTPS\n- JWT\n---\n### HTTP与HTTPS\n* HTTP的缺点 及 解决方案\n    * 通信使用明文(不加密)，内容可能被窃听\n        > 加密\n    * 不验证通信方的身份，因此有可能遭遇伪装（假的server或client）\n        > 证书 （支持双向验证，但通常只验证服务端.）  \n        > SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份\n    * 无法证明报文的完整性，所以有可能已遭篡改\n        > 基于散列值校验（MD5 / SHA-1）等等的完整性校验方案   \n* HTTPS可以完美解决以上问题\n    >* **HTTP + 加密 + 认证 + 完整性保护 = HTTPS**      \n    >* 请求包可以被截获，但无法解密读取\n    >* 对于HTTPS不做赘述，下面仅附图一张    \n    ![图解HTTPS](/images/图解HTTPS.png)\n<!--more-->\n* 既然HTTPS那么安全可靠，那为何所有的网站不一直使用HTTPS ？\n    * HTTPS比HTTP慢2到100倍\n        * 通信慢\n            > TCP/IP之上还需要SSL通信\n        * 消耗更多的CPU和内存\n            > 客户端和服务端都必须加密解密运算，\n    * 证书的开销\n    \n### HTTP + TOKEN：每次请请求都携带**经过加密且被签名的token**\n* 无状态，可快速验证用户的有效性\n* 加密，防止token被读取篡改\n* 但是第三方可以用截取到的token伪造请求，所以client有被劫持的风险；签名和设置有效期可以解决\n    * GET等非敏感请求\n        * 设置token的有效期\"per session cookies, and per request\" -- 防CSRF\n        * 对于GET，token的签名包含url，确保token和URL是对应的没被更改的 -- 请求顶多被窃听\n            > 例如Get请求时，将parameters加入到签名里，从而防止被篡改；但仍然可以被监听.   \n            POST请求则直接对请求体做MD5计算，将MD5值加入签名.\n    * POST等敏感请求，用HTTPS\n\n### 最终选择\n* 首选HTTPS，如果不用考虑性能和money的话\n    > 认证可随意选择，用户名密码或者简单token\n* HTTP + **token**，请求体、相应体有被监听的风险\n    >1. 提前约定secret、加密方式等   \n    >2. 每次请求都生成唯一的经过加密和签名的token\n    >3. 将md5(requestContent/parameter)作为签名的一部分，避免劫持   \n        上面两点**无法防止伪装**，token可以被窃取，从而有被劫持.可以将md5(requestContent/parameter)作为签名的一部分，避免劫持，顶多有被监听的风险，因为信息不明感，从而可忽略\n* HTTP和HTTPS组合使用\n    * 非敏感信息使用HTTP + **token**的认证方式\n    * 只有在接触敏感信息时才使用HTTPS，如登录\n\n### 反推TOKEN的特性\n* 加密，不可被窃听\n    >1. 加密方式\n    >2. 秘钥\n    >3. 对于API，一般不要求登录，所以用户名和密钥要提前约定好.\n* 签名，可以证明请求没有没篡改\n* 有效期设置功能，防止被窃取后伪造请求；如果是浏览器访问也可以解决CSRF\n    * “**per session cookies, and per request tokens**.”， 可以解决CSRF，但不能解决监听问题。\n    * API不存在CSRF问题，但如果token永不过期，截取到token便可以伪造请求了，所以可以为API的token设置一个长点的过期时间\n    * 所以建议：\n        * API\n            >* 非敏感数据的API过期设的长一些，以免让client频繁请求token\n            >* 敏感数据直接升级用HTTPS\n        * B/S\n            >* HTTPS + per request token\n\n### 案例\n* 去哪儿，HTTP+TOKEN 和 HTTPS\n    * 非敏感数据采用 HTTP + TOKEN\n        ``` java\n        String sign = DigestUtils.md5Hex(DigestUtils.md5Hex(secretKey + appKey) + salt);\n        ```\n        > appKey、secretKey提前约定好   \n        没有有效期，截取sign后可以长期伪装client, 发送重复请求。   \n        没有签名， 伪装client，且可以更改请求\n    \n* 亮哥，HTTP + TOKEN\n    ``` java\n    String sign = md5(userId + timestamps + secret);//per request timestamps\n    ```\n    > server端记录每次请求的timestamps, 当次有效   \n    没有签名， 可以被劫持，从而更改请求\n    \n    \n    \n\n### 伪装问题\n* HTTPS不存在伪装问题\n    >1. 有证书保证server身份，所以无法伪装server   \n    >2. 在用户名密码不被泄露的情况下，能建立起SSL的就是真正的用户\n* HTTP虽然无法彻底解决伪装问题，但是因为token的不可更改不可窃听的属性，伪装被降级成转发监听\n    > 由于token是不可读，不可修改的，所以第三方无法伪造只能引用.   \n    又因为加了有效期，所以第三方最多只能转发监听\n\n#### Client-side/Stateless Sessions (客户端持有的/无状态session)\n* stateless\n    >只保存客户数据  \n    \n* JWT不可被第三方 读取 和 更改\n    >签名 = 不可更改  \n    加密 = 不可读\n    \n#### Cross-Site Request Forgery (CSRF - 跨站请求伪造)\n* 由于同一浏览器进程下 Cookie 可见性，导致用户身份被盗用，完成恶意网站脚本中指定的操作\n\n* 解决方案\n    > “**per session cookies, and per request tokens**.”  \n    \n* 案例一\n    1. 客户端每个request都必须携带 userId + **timestamps** + token\n        > token = md5(userId + secret + timestamps**)，确保信息不被更改\n    2. timestamps只能使用一次\n        > 服务端先校验timestamps是否已经被处理，如果已经处理，拒绝请求\n    3. 服务端根据收到的userId + timestamps和约定好的secret计算token，然后和收到的token进行比较校验\n    ","slug":"HTTP_HTTPS_Token","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdbzy00009t9c0kyyh0dp","content":"<h3 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h3><ul>\n<li>HTTP的缺点 及 解决方案<ul>\n<li>通信使用明文(不加密)，内容可能被窃听<blockquote>\n<p>加密</p>\n</blockquote>\n</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装（假的server或client）<blockquote>\n<p>证书 （支持双向验证，但通常只验证服务端.）<br>SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份</p>\n</blockquote>\n</li>\n<li>无法证明报文的完整性，所以有可能已遭篡改<blockquote>\n<p>基于散列值校验（MD5 / SHA-1）等等的完整性校验方案   </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>HTTPS可以完美解决以上问题<blockquote>\n<ul>\n<li><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong>      </li>\n<li>请求包可以被截获，但无法解密读取</li>\n<li>对于HTTPS不做赘述，下面仅附图一张<br><img src=\"/images/图解HTTPS.png\" alt=\"图解HTTPS\"><a id=\"more\"></a></li>\n</ul>\n</blockquote>\n</li>\n<li>既然HTTPS那么安全可靠，那为何所有的网站不一直使用HTTPS ？<ul>\n<li>HTTPS比HTTP慢2到100倍<ul>\n<li>通信慢<blockquote>\n<p>TCP/IP之上还需要SSL通信</p>\n</blockquote>\n</li>\n<li>消耗更多的CPU和内存<blockquote>\n<p>客户端和服务端都必须加密解密运算，</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>证书的开销</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP-TOKEN：每次请请求都携带经过加密且被签名的token\"><a href=\"#HTTP-TOKEN：每次请请求都携带经过加密且被签名的token\" class=\"headerlink\" title=\"HTTP + TOKEN：每次请请求都携带经过加密且被签名的token\"></a>HTTP + TOKEN：每次请请求都携带<strong>经过加密且被签名的token</strong></h3><ul>\n<li>无状态，可快速验证用户的有效性</li>\n<li>加密，防止token被读取篡改</li>\n<li>但是第三方可以用截取到的token伪造请求，所以client有被劫持的风险；签名和设置有效期可以解决<ul>\n<li>GET等非敏感请求<ul>\n<li>设置token的有效期”per session cookies, and per request” – 防CSRF</li>\n<li>对于GET，token的签名包含url，确保token和URL是对应的没被更改的 – 请求顶多被窃听<blockquote>\n<p>例如Get请求时，将parameters加入到签名里，从而防止被篡改；但仍然可以被监听.<br>  POST请求则直接对请求体做MD5计算，将MD5值加入签名.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>POST等敏感请求，用HTTPS</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最终选择\"><a href=\"#最终选择\" class=\"headerlink\" title=\"最终选择\"></a>最终选择</h3><ul>\n<li>首选HTTPS，如果不用考虑性能和money的话<blockquote>\n<p>认证可随意选择，用户名密码或者简单token</p>\n</blockquote>\n</li>\n<li>HTTP + <strong>token</strong>，请求体、相应体有被监听的风险<blockquote>\n<ol>\n<li>提前约定secret、加密方式等   </li>\n<li>每次请求都生成唯一的经过加密和签名的token</li>\n<li>将md5(requestContent/parameter)作为签名的一部分，避免劫持<br>   上面两点<strong>无法防止伪装</strong>，token可以被窃取，从而有被劫持.可以将md5(requestContent/parameter)作为签名的一部分，避免劫持，顶多有被监听的风险，因为信息不明感，从而可忽略</li>\n</ol>\n</blockquote>\n</li>\n<li>HTTP和HTTPS组合使用<ul>\n<li>非敏感信息使用HTTP + <strong>token</strong>的认证方式</li>\n<li>只有在接触敏感信息时才使用HTTPS，如登录</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"反推TOKEN的特性\"><a href=\"#反推TOKEN的特性\" class=\"headerlink\" title=\"反推TOKEN的特性\"></a>反推TOKEN的特性</h3><ul>\n<li>加密，不可被窃听<blockquote>\n<ol>\n<li>加密方式</li>\n<li>秘钥</li>\n<li>对于API，一般不要求登录，所以用户名和密钥要提前约定好.</li>\n</ol>\n</blockquote>\n</li>\n<li>签名，可以证明请求没有没篡改</li>\n<li>有效期设置功能，防止被窃取后伪造请求；如果是浏览器访问也可以解决CSRF<ul>\n<li>“<strong>per session cookies, and per request tokens</strong>.”， 可以解决CSRF，但不能解决监听问题。</li>\n<li>API不存在CSRF问题，但如果token永不过期，截取到token便可以伪造请求了，所以可以为API的token设置一个长点的过期时间</li>\n<li>所以建议：<ul>\n<li>API<blockquote>\n<ul>\n<li>非敏感数据的API过期设的长一些，以免让client频繁请求token</li>\n<li>敏感数据直接升级用HTTPS</li>\n</ul>\n</blockquote>\n</li>\n<li>B/S<blockquote>\n<ul>\n<li>HTTPS + per request token</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ul>\n<li><p>去哪儿，HTTP+TOKEN 和 HTTPS</p>\n<ul>\n<li><p>非敏感数据采用 HTTP + TOKEN</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sign = DigestUtils.md5Hex(DigestUtils.md5Hex(secretKey + appKey) + salt);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>appKey、secretKey提前约定好<br>  没有有效期，截取sign后可以长期伪装client, 发送重复请求。<br>  没有签名， 伪装client，且可以更改请求</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>亮哥，HTTP + TOKEN</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sign = md5(userId + timestamps + secret);<span class=\"comment\">//per request timestamps</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>server端记录每次请求的timestamps, 当次有效<br>  没有签名， 可以被劫持，从而更改请求</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"伪装问题\"><a href=\"#伪装问题\" class=\"headerlink\" title=\"伪装问题\"></a>伪装问题</h3><ul>\n<li>HTTPS不存在伪装问题<blockquote>\n<ol>\n<li>有证书保证server身份，所以无法伪装server   </li>\n<li>在用户名密码不被泄露的情况下，能建立起SSL的就是真正的用户</li>\n</ol>\n</blockquote>\n</li>\n<li>HTTP虽然无法彻底解决伪装问题，但是因为token的不可更改不可窃听的属性，伪装被降级成转发监听<blockquote>\n<p>由于token是不可读，不可修改的，所以第三方无法伪造只能引用.<br>  又因为加了有效期，所以第三方最多只能转发监听</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Client-side-Stateless-Sessions-客户端持有的-无状态session\"><a href=\"#Client-side-Stateless-Sessions-客户端持有的-无状态session\" class=\"headerlink\" title=\"Client-side/Stateless Sessions (客户端持有的/无状态session)\"></a>Client-side/Stateless Sessions (客户端持有的/无状态session)</h4><ul>\n<li><p>stateless</p>\n<blockquote>\n<p>只保存客户数据  </p>\n</blockquote>\n</li>\n<li><p>JWT不可被第三方 读取 和 更改</p>\n<blockquote>\n<p>签名 = 不可更改<br>  加密 = 不可读</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cross-Site-Request-Forgery-CSRF-跨站请求伪造\"><a href=\"#Cross-Site-Request-Forgery-CSRF-跨站请求伪造\" class=\"headerlink\" title=\"Cross-Site Request Forgery (CSRF - 跨站请求伪造)\"></a>Cross-Site Request Forgery (CSRF - 跨站请求伪造)</h4><ul>\n<li><p>由于同一浏览器进程下 Cookie 可见性，导致用户身份被盗用，完成恶意网站脚本中指定的操作</p>\n</li>\n<li><p>解决方案</p>\n<blockquote>\n<p>“<strong>per session cookies, and per request tokens</strong>.”  </p>\n</blockquote>\n</li>\n<li><p>案例一</p>\n<ol>\n<li>客户端每个request都必须携带 userId + <strong>timestamps</strong> + token<blockquote>\n<p>token = md5(userId + secret + timestamps**)，确保信息不被更改</p>\n</blockquote>\n</li>\n<li>timestamps只能使用一次<blockquote>\n<p>服务端先校验timestamps是否已经被处理，如果已经处理，拒绝请求</p>\n</blockquote>\n</li>\n<li>服务端根据收到的userId + timestamps和约定好的secret计算token，然后和收到的token进行比较校验</li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"HTTP与HTTPS\"><a href=\"#HTTP与HTTPS\" class=\"headerlink\" title=\"HTTP与HTTPS\"></a>HTTP与HTTPS</h3><ul>\n<li>HTTP的缺点 及 解决方案<ul>\n<li>通信使用明文(不加密)，内容可能被窃听<blockquote>\n<p>加密</p>\n</blockquote>\n</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装（假的server或client）<blockquote>\n<p>证书 （支持双向验证，但通常只验证服务端.）<br>SSL客户端的身份验证是可选的，由SSL服务器决定是否验证SSL客户端的身份</p>\n</blockquote>\n</li>\n<li>无法证明报文的完整性，所以有可能已遭篡改<blockquote>\n<p>基于散列值校验（MD5 / SHA-1）等等的完整性校验方案   </p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>HTTPS可以完美解决以上问题<blockquote>\n<ul>\n<li><strong>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</strong>      </li>\n<li>请求包可以被截获，但无法解密读取</li>\n<li>对于HTTPS不做赘述，下面仅附图一张<br><img src=\"/images/图解HTTPS.png\" alt=\"图解HTTPS\">","more":"</li>\n</ul>\n</blockquote>\n</li>\n<li>既然HTTPS那么安全可靠，那为何所有的网站不一直使用HTTPS ？<ul>\n<li>HTTPS比HTTP慢2到100倍<ul>\n<li>通信慢<blockquote>\n<p>TCP/IP之上还需要SSL通信</p>\n</blockquote>\n</li>\n<li>消耗更多的CPU和内存<blockquote>\n<p>客户端和服务端都必须加密解密运算，</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>证书的开销</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTP-TOKEN：每次请请求都携带经过加密且被签名的token\"><a href=\"#HTTP-TOKEN：每次请请求都携带经过加密且被签名的token\" class=\"headerlink\" title=\"HTTP + TOKEN：每次请请求都携带经过加密且被签名的token\"></a>HTTP + TOKEN：每次请请求都携带<strong>经过加密且被签名的token</strong></h3><ul>\n<li>无状态，可快速验证用户的有效性</li>\n<li>加密，防止token被读取篡改</li>\n<li>但是第三方可以用截取到的token伪造请求，所以client有被劫持的风险；签名和设置有效期可以解决<ul>\n<li>GET等非敏感请求<ul>\n<li>设置token的有效期”per session cookies, and per request” – 防CSRF</li>\n<li>对于GET，token的签名包含url，确保token和URL是对应的没被更改的 – 请求顶多被窃听<blockquote>\n<p>例如Get请求时，将parameters加入到签名里，从而防止被篡改；但仍然可以被监听.<br>  POST请求则直接对请求体做MD5计算，将MD5值加入签名.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>POST等敏感请求，用HTTPS</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"最终选择\"><a href=\"#最终选择\" class=\"headerlink\" title=\"最终选择\"></a>最终选择</h3><ul>\n<li>首选HTTPS，如果不用考虑性能和money的话<blockquote>\n<p>认证可随意选择，用户名密码或者简单token</p>\n</blockquote>\n</li>\n<li>HTTP + <strong>token</strong>，请求体、相应体有被监听的风险<blockquote>\n<ol>\n<li>提前约定secret、加密方式等   </li>\n<li>每次请求都生成唯一的经过加密和签名的token</li>\n<li>将md5(requestContent/parameter)作为签名的一部分，避免劫持<br>   上面两点<strong>无法防止伪装</strong>，token可以被窃取，从而有被劫持.可以将md5(requestContent/parameter)作为签名的一部分，避免劫持，顶多有被监听的风险，因为信息不明感，从而可忽略</li>\n</ol>\n</blockquote>\n</li>\n<li>HTTP和HTTPS组合使用<ul>\n<li>非敏感信息使用HTTP + <strong>token</strong>的认证方式</li>\n<li>只有在接触敏感信息时才使用HTTPS，如登录</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"反推TOKEN的特性\"><a href=\"#反推TOKEN的特性\" class=\"headerlink\" title=\"反推TOKEN的特性\"></a>反推TOKEN的特性</h3><ul>\n<li>加密，不可被窃听<blockquote>\n<ol>\n<li>加密方式</li>\n<li>秘钥</li>\n<li>对于API，一般不要求登录，所以用户名和密钥要提前约定好.</li>\n</ol>\n</blockquote>\n</li>\n<li>签名，可以证明请求没有没篡改</li>\n<li>有效期设置功能，防止被窃取后伪造请求；如果是浏览器访问也可以解决CSRF<ul>\n<li>“<strong>per session cookies, and per request tokens</strong>.”， 可以解决CSRF，但不能解决监听问题。</li>\n<li>API不存在CSRF问题，但如果token永不过期，截取到token便可以伪造请求了，所以可以为API的token设置一个长点的过期时间</li>\n<li>所以建议：<ul>\n<li>API<blockquote>\n<ul>\n<li>非敏感数据的API过期设的长一些，以免让client频繁请求token</li>\n<li>敏感数据直接升级用HTTPS</li>\n</ul>\n</blockquote>\n</li>\n<li>B/S<blockquote>\n<ul>\n<li>HTTPS + per request token</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><ul>\n<li><p>去哪儿，HTTP+TOKEN 和 HTTPS</p>\n<ul>\n<li><p>非敏感数据采用 HTTP + TOKEN</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sign = DigestUtils.md5Hex(DigestUtils.md5Hex(secretKey + appKey) + salt);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>appKey、secretKey提前约定好<br>  没有有效期，截取sign后可以长期伪装client, 发送重复请求。<br>  没有签名， 伪装client，且可以更改请求</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>亮哥，HTTP + TOKEN</p>\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sign = md5(userId + timestamps + secret);<span class=\"comment\">//per request timestamps</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>server端记录每次请求的timestamps, 当次有效<br>  没有签名， 可以被劫持，从而更改请求</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"伪装问题\"><a href=\"#伪装问题\" class=\"headerlink\" title=\"伪装问题\"></a>伪装问题</h3><ul>\n<li>HTTPS不存在伪装问题<blockquote>\n<ol>\n<li>有证书保证server身份，所以无法伪装server   </li>\n<li>在用户名密码不被泄露的情况下，能建立起SSL的就是真正的用户</li>\n</ol>\n</blockquote>\n</li>\n<li>HTTP虽然无法彻底解决伪装问题，但是因为token的不可更改不可窃听的属性，伪装被降级成转发监听<blockquote>\n<p>由于token是不可读，不可修改的，所以第三方无法伪造只能引用.<br>  又因为加了有效期，所以第三方最多只能转发监听</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Client-side-Stateless-Sessions-客户端持有的-无状态session\"><a href=\"#Client-side-Stateless-Sessions-客户端持有的-无状态session\" class=\"headerlink\" title=\"Client-side/Stateless Sessions (客户端持有的/无状态session)\"></a>Client-side/Stateless Sessions (客户端持有的/无状态session)</h4><ul>\n<li><p>stateless</p>\n<blockquote>\n<p>只保存客户数据  </p>\n</blockquote>\n</li>\n<li><p>JWT不可被第三方 读取 和 更改</p>\n<blockquote>\n<p>签名 = 不可更改<br>  加密 = 不可读</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cross-Site-Request-Forgery-CSRF-跨站请求伪造\"><a href=\"#Cross-Site-Request-Forgery-CSRF-跨站请求伪造\" class=\"headerlink\" title=\"Cross-Site Request Forgery (CSRF - 跨站请求伪造)\"></a>Cross-Site Request Forgery (CSRF - 跨站请求伪造)</h4><ul>\n<li><p>由于同一浏览器进程下 Cookie 可见性，导致用户身份被盗用，完成恶意网站脚本中指定的操作</p>\n</li>\n<li><p>解决方案</p>\n<blockquote>\n<p>“<strong>per session cookies, and per request tokens</strong>.”  </p>\n</blockquote>\n</li>\n<li><p>案例一</p>\n<ol>\n<li>客户端每个request都必须携带 userId + <strong>timestamps</strong> + token<blockquote>\n<p>token = md5(userId + secret + timestamps**)，确保信息不被更改</p>\n</blockquote>\n</li>\n<li>timestamps只能使用一次<blockquote>\n<p>服务端先校验timestamps是否已经被处理，如果已经处理，拒绝请求</p>\n</blockquote>\n</li>\n<li>服务端根据收到的userId + timestamps和约定好的secret计算token，然后和收到的token进行比较校验</li>\n</ol>\n</li>\n</ul>"},{"title":"知识体系总览","date":"2018-03-31T03:29:11.000Z","_content":"![图解HTTPS](/images/知识体系总览.pdf)\n<!-- more --> ","source":"_posts/knowledge-hierarchy.md","raw":"---\ntitle: 知识体系总览\ndate: 2018-03-31 11:29:11\ncategories: \n- 知识体系\n---\n![图解HTTPS](/images/知识体系总览.pdf)\n<!-- more --> ","slug":"knowledge-hierarchy","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0300029t9cxl20tizn","content":"<p><img src=\"/images/知识体系总览.pdf\" alt=\"图解HTTPS\"><br><a id=\"more\"></a> </p>\n","site":{"data":{}},"excerpt":"<p><img src=\"/images/知识体系总览.pdf\" alt=\"图解HTTPS\"><br>","more":"</p>"},{"title":"Redis实战（Redis IN ACTION）","date":"2018-03-14T16:00:00.000Z","_content":"#### 第1章 初识Redis\n* Redis的优点\n    >比关系型数据库更效率、更易用；比内存数据库有数据结构上的优势\n    \n    * 高性能内存数据库，但支持持久化《RDB, AOF》\n    * 5种数据结构 《string, List, set, hash, zset\n    * 第6种数据结构：pub/sub\n    * 简单事务\n    * 过期机制\n    * 主从复制 -> 扩展读性能，故障转移\n<!--more-->\n#### 第4章 数据安全与性能保障\n* 4.1 持久化选项\n    >* 快照持久化<SNAPSHOT/RDB、AOF>\n    >* 从服务器的复制启动过程<第一次同步>\n    \n    * SNAPSHOT/RDB <高效恢复数据，但是有停顿，丢数据>\n        * BGSAVE\n            * fork子进程 -> 停顿 <生成子进程的过程会阻塞父进程>\n              >可关闭自动保存，手动触发\n              \n            * 内存不足时 -> 使用虚拟内存\n                >master内存使用率应在50%~65%\n                \n        * SAVE\n            * 没有子进程，故比BGSAVE快\n        * 数据完整性\n            * 可承受丢失多长时间的数据？\n                >save 60 1000\n                \n            * 丢失了那些数据？ -> process_logs()\n                >保证日志的处理结果和处理进度总是同时被记录到快照文件里面\n                \n    * AOF \n        >1. 不丢数据，无停顿，但恢复慢，日志体积大\n        >2. 主从写更新\n        \n        * 同步频率<appendfsync选项>\n            * always<每次写都触发同步，每次只写入一个命令> -> 最慢\n            * everysec<每秒触发一次同步> -> 推荐\n            * no<操作系统自动决定同步时机> -> 不推荐\n        * 重写/压缩AOF文件\n            * BGREWRITEAOF -> 工作机制同BGSAVE，停顿\n            * 何时执行BGREWRITEAOF？\n                * auto-aof-rewrite-percentage\n                * auto-aof-rewirte-min-size\n* 4.2 复制(replication)\n    * 主从复制 <不支持多主复制>\n    * 复制的启动过程\n    * 主从链\n        * 复制中间层 -> 分担主服务器的复制工作\n    * 检查硬盘写入\n    * conn.info()….\n* 4.3 处理系统故障\n    * 验证AOF文件\n        >可修复\n    * 验证快照文件\n        >* 不可修复\n        >* 恢复前需验证快照文件<SHA1/SHA256>\n    * 更换故障主服务器、Redis Sentinel的故障转移\n* 4.4 事务\n    * watch + retry\n        >如果数据被更改，收到watch的通知，然后重试\n    * 流水线（pipelining）方式：pipe.multi + pipe.execute\n        >一次性发送多个命令，然后等待所有回复出现<如果执行过程中，接到watchError则失败>\n* 4.5 非事务型流水线\n    * pipe = conn.pipeline(false)   《单纯的把多个命令打包，一起发送》","source":"_posts/redisInAction.md","raw":"---\ntitle: Redis实战（Redis IN ACTION）\ndate: 2018-03-15\ncategories: \n- readNote\ntags:\n- Redis\n---\n#### 第1章 初识Redis\n* Redis的优点\n    >比关系型数据库更效率、更易用；比内存数据库有数据结构上的优势\n    \n    * 高性能内存数据库，但支持持久化《RDB, AOF》\n    * 5种数据结构 《string, List, set, hash, zset\n    * 第6种数据结构：pub/sub\n    * 简单事务\n    * 过期机制\n    * 主从复制 -> 扩展读性能，故障转移\n<!--more-->\n#### 第4章 数据安全与性能保障\n* 4.1 持久化选项\n    >* 快照持久化<SNAPSHOT/RDB、AOF>\n    >* 从服务器的复制启动过程<第一次同步>\n    \n    * SNAPSHOT/RDB <高效恢复数据，但是有停顿，丢数据>\n        * BGSAVE\n            * fork子进程 -> 停顿 <生成子进程的过程会阻塞父进程>\n              >可关闭自动保存，手动触发\n              \n            * 内存不足时 -> 使用虚拟内存\n                >master内存使用率应在50%~65%\n                \n        * SAVE\n            * 没有子进程，故比BGSAVE快\n        * 数据完整性\n            * 可承受丢失多长时间的数据？\n                >save 60 1000\n                \n            * 丢失了那些数据？ -> process_logs()\n                >保证日志的处理结果和处理进度总是同时被记录到快照文件里面\n                \n    * AOF \n        >1. 不丢数据，无停顿，但恢复慢，日志体积大\n        >2. 主从写更新\n        \n        * 同步频率<appendfsync选项>\n            * always<每次写都触发同步，每次只写入一个命令> -> 最慢\n            * everysec<每秒触发一次同步> -> 推荐\n            * no<操作系统自动决定同步时机> -> 不推荐\n        * 重写/压缩AOF文件\n            * BGREWRITEAOF -> 工作机制同BGSAVE，停顿\n            * 何时执行BGREWRITEAOF？\n                * auto-aof-rewrite-percentage\n                * auto-aof-rewirte-min-size\n* 4.2 复制(replication)\n    * 主从复制 <不支持多主复制>\n    * 复制的启动过程\n    * 主从链\n        * 复制中间层 -> 分担主服务器的复制工作\n    * 检查硬盘写入\n    * conn.info()….\n* 4.3 处理系统故障\n    * 验证AOF文件\n        >可修复\n    * 验证快照文件\n        >* 不可修复\n        >* 恢复前需验证快照文件<SHA1/SHA256>\n    * 更换故障主服务器、Redis Sentinel的故障转移\n* 4.4 事务\n    * watch + retry\n        >如果数据被更改，收到watch的通知，然后重试\n    * 流水线（pipelining）方式：pipe.multi + pipe.execute\n        >一次性发送多个命令，然后等待所有回复出现<如果执行过程中，接到watchError则失败>\n* 4.5 非事务型流水线\n    * pipe = conn.pipeline(false)   《单纯的把多个命令打包，一起发送》","slug":"redisInAction","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0900069t9cehpfhgib","content":"<h4 id=\"第1章-初识Redis\"><a href=\"#第1章-初识Redis\" class=\"headerlink\" title=\"第1章 初识Redis\"></a>第1章 初识Redis</h4><ul>\n<li><p>Redis的优点</p>\n<blockquote>\n<p>比关系型数据库更效率、更易用；比内存数据库有数据结构上的优势</p>\n</blockquote>\n<ul>\n<li>高性能内存数据库，但支持持久化《RDB, AOF》</li>\n<li>5种数据结构 《string, List, set, hash, zset</li>\n<li>第6种数据结构：pub/sub</li>\n<li>简单事务</li>\n<li>过期机制</li>\n<li>主从复制 -&gt; 扩展读性能，故障转移<a id=\"more\"></a>\n<h4 id=\"第4章-数据安全与性能保障\"><a href=\"#第4章-数据安全与性能保障\" class=\"headerlink\" title=\"第4章 数据安全与性能保障\"></a>第4章 数据安全与性能保障</h4></li>\n</ul>\n</li>\n<li><p>4.1 持久化选项</p>\n<blockquote>\n<ul>\n<li>快照持久化&lt;SNAPSHOT/RDB、AOF&gt;</li>\n<li>从服务器的复制启动过程&lt;第一次同步&gt;</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>SNAPSHOT/RDB &lt;高效恢复数据，但是有停顿，丢数据&gt;</p>\n<ul>\n<li><p>BGSAVE</p>\n<ul>\n<li><p>fork子进程 -&gt; 停顿 &lt;生成子进程的过程会阻塞父进程&gt;</p>\n<blockquote>\n<p>可关闭自动保存，手动触发</p>\n</blockquote>\n</li>\n<li><p>内存不足时 -&gt; 使用虚拟内存</p>\n<blockquote>\n<p>master内存使用率应在50%~65%</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>SAVE</p>\n<ul>\n<li>没有子进程，故比BGSAVE快</li>\n</ul>\n</li>\n<li><p>数据完整性</p>\n<ul>\n<li><p>可承受丢失多长时间的数据？</p>\n<blockquote>\n<p>save 60 1000</p>\n</blockquote>\n</li>\n<li><p>丢失了那些数据？ -&gt; process_logs()</p>\n<blockquote>\n<p>保证日志的处理结果和处理进度总是同时被记录到快照文件里面</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AOF </p>\n<blockquote>\n<ol>\n<li>不丢数据，无停顿，但恢复慢，日志体积大</li>\n<li>主从写更新</li>\n</ol>\n</blockquote>\n<ul>\n<li>同步频率&lt;appendfsync选项&gt;<ul>\n<li>always&lt;每次写都触发同步，每次只写入一个命令&gt; -&gt; 最慢</li>\n<li>everysec&lt;每秒触发一次同步&gt; -&gt; 推荐</li>\n<li>no&lt;操作系统自动决定同步时机&gt; -&gt; 不推荐</li>\n</ul>\n</li>\n<li>重写/压缩AOF文件<ul>\n<li>BGREWRITEAOF -&gt; 工作机制同BGSAVE，停顿</li>\n<li>何时执行BGREWRITEAOF？<ul>\n<li>auto-aof-rewrite-percentage</li>\n<li>auto-aof-rewirte-min-size</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.2 复制(replication)<ul>\n<li>主从复制 &lt;不支持多主复制&gt;</li>\n<li>复制的启动过程</li>\n<li>主从链<ul>\n<li>复制中间层 -&gt; 分担主服务器的复制工作</li>\n</ul>\n</li>\n<li>检查硬盘写入</li>\n<li>conn.info()….</li>\n</ul>\n</li>\n<li>4.3 处理系统故障<ul>\n<li>验证AOF文件<blockquote>\n<p>可修复</p>\n</blockquote>\n</li>\n<li>验证快照文件<blockquote>\n<ul>\n<li>不可修复</li>\n<li>恢复前需验证快照文件&lt;SHA1/SHA256&gt;</li>\n</ul>\n</blockquote>\n</li>\n<li>更换故障主服务器、Redis Sentinel的故障转移</li>\n</ul>\n</li>\n<li>4.4 事务<ul>\n<li>watch + retry<blockquote>\n<p>如果数据被更改，收到watch的通知，然后重试</p>\n</blockquote>\n</li>\n<li>流水线（pipelining）方式：pipe.multi + pipe.execute<blockquote>\n<p>一次性发送多个命令，然后等待所有回复出现&lt;如果执行过程中，接到watchError则失败&gt;</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>4.5 非事务型流水线<ul>\n<li>pipe = conn.pipeline(false)   《单纯的把多个命令打包，一起发送》</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h4 id=\"第1章-初识Redis\"><a href=\"#第1章-初识Redis\" class=\"headerlink\" title=\"第1章 初识Redis\"></a>第1章 初识Redis</h4><ul>\n<li><p>Redis的优点</p>\n<blockquote>\n<p>比关系型数据库更效率、更易用；比内存数据库有数据结构上的优势</p>\n</blockquote>\n<ul>\n<li>高性能内存数据库，但支持持久化《RDB, AOF》</li>\n<li>5种数据结构 《string, List, set, hash, zset</li>\n<li>第6种数据结构：pub/sub</li>\n<li>简单事务</li>\n<li>过期机制</li>\n<li>主从复制 -&gt; 扩展读性能，故障转移","more":"<h4 id=\"第4章-数据安全与性能保障\"><a href=\"#第4章-数据安全与性能保障\" class=\"headerlink\" title=\"第4章 数据安全与性能保障\"></a>第4章 数据安全与性能保障</h4></li>\n</ul>\n</li>\n<li><p>4.1 持久化选项</p>\n<blockquote>\n<ul>\n<li>快照持久化&lt;SNAPSHOT/RDB、AOF&gt;</li>\n<li>从服务器的复制启动过程&lt;第一次同步&gt;</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>SNAPSHOT/RDB &lt;高效恢复数据，但是有停顿，丢数据&gt;</p>\n<ul>\n<li><p>BGSAVE</p>\n<ul>\n<li><p>fork子进程 -&gt; 停顿 &lt;生成子进程的过程会阻塞父进程&gt;</p>\n<blockquote>\n<p>可关闭自动保存，手动触发</p>\n</blockquote>\n</li>\n<li><p>内存不足时 -&gt; 使用虚拟内存</p>\n<blockquote>\n<p>master内存使用率应在50%~65%</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>SAVE</p>\n<ul>\n<li>没有子进程，故比BGSAVE快</li>\n</ul>\n</li>\n<li><p>数据完整性</p>\n<ul>\n<li><p>可承受丢失多长时间的数据？</p>\n<blockquote>\n<p>save 60 1000</p>\n</blockquote>\n</li>\n<li><p>丢失了那些数据？ -&gt; process_logs()</p>\n<blockquote>\n<p>保证日志的处理结果和处理进度总是同时被记录到快照文件里面</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AOF </p>\n<blockquote>\n<ol>\n<li>不丢数据，无停顿，但恢复慢，日志体积大</li>\n<li>主从写更新</li>\n</ol>\n</blockquote>\n<ul>\n<li>同步频率&lt;appendfsync选项&gt;<ul>\n<li>always&lt;每次写都触发同步，每次只写入一个命令&gt; -&gt; 最慢</li>\n<li>everysec&lt;每秒触发一次同步&gt; -&gt; 推荐</li>\n<li>no&lt;操作系统自动决定同步时机&gt; -&gt; 不推荐</li>\n</ul>\n</li>\n<li>重写/压缩AOF文件<ul>\n<li>BGREWRITEAOF -&gt; 工作机制同BGSAVE，停顿</li>\n<li>何时执行BGREWRITEAOF？<ul>\n<li>auto-aof-rewrite-percentage</li>\n<li>auto-aof-rewirte-min-size</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>4.2 复制(replication)<ul>\n<li>主从复制 &lt;不支持多主复制&gt;</li>\n<li>复制的启动过程</li>\n<li>主从链<ul>\n<li>复制中间层 -&gt; 分担主服务器的复制工作</li>\n</ul>\n</li>\n<li>检查硬盘写入</li>\n<li>conn.info()….</li>\n</ul>\n</li>\n<li>4.3 处理系统故障<ul>\n<li>验证AOF文件<blockquote>\n<p>可修复</p>\n</blockquote>\n</li>\n<li>验证快照文件<blockquote>\n<ul>\n<li>不可修复</li>\n<li>恢复前需验证快照文件&lt;SHA1/SHA256&gt;</li>\n</ul>\n</blockquote>\n</li>\n<li>更换故障主服务器、Redis Sentinel的故障转移</li>\n</ul>\n</li>\n<li>4.4 事务<ul>\n<li>watch + retry<blockquote>\n<p>如果数据被更改，收到watch的通知，然后重试</p>\n</blockquote>\n</li>\n<li>流水线（pipelining）方式：pipe.multi + pipe.execute<blockquote>\n<p>一次性发送多个命令，然后等待所有回复出现&lt;如果执行过程中，接到watchError则失败&gt;</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>4.5 非事务型流水线<ul>\n<li>pipe = conn.pipeline(false)   《单纯的把多个命令打包，一起发送》</li>\n</ul>\n</li>\n</ul>"},{"title":"以企业的方式经营家庭","date":"2018-03-17T09:16:15.000Z","_content":"## 想法的产生\n16年看着《管理的实践》却不知道何为公司；认识老婆后便萌生了以企业的方式经营家庭的想法。想着\"以企业的方式经营家庭\"可以\n > * 促使我去了解\"企业\"到底是什么，为以后的创业做铺垫\n > * 目标管理的实践：家庭目标 & 个人目标的平衡\n > * 从一个人变成了一家人，从而必须以组织的角度重新审视\"家\"\n > * 摆脱浑浑噩噩\n \n最近又重新饱受焦虑的困扰，所以迫使着重新梳理了下目标；再加上和老婆生活上的小摩擦让我坚定了这一想法，决定立即实施。\n \n## 家庭企业的建立\n### 家庭适用**有限合伙企业**\n    从下图中可以很快发现，\"有限合伙企业\"和\"家庭\"最贴切（夫妻双方为普通合伙人，父母孩子皆为有限合伙人）。\n \n ![企业类型](/images/企业类型.png)\n### 有限合伙企业成员的角色、权利、义务 \n * 夫妻，普通合伙人，以预算的方式分配企业所得，承担**无限连带责任**\n * 父母，有限合伙人，参与固定分红以及分享一定应急资金，承担有限责任（带孩子等）\n * 孩子，战略性投资项目（因为没有投入和不承担责任所以不应作为合伙人而存在），享受预算优先权，不承担任何责任\n \n### **合伙协议**，按企业法应包含如下内容：\n 1. 普通合伙人和有限合伙人的姓名或者名称、住所；\n    > 略\n 2. 执行事务合伙人应具备的条件和选择程序；\n    > 夫妻两人皆为执行事务合伙人，投票权完全相同\n 3. 执行事务合伙人权限与违约处理办法；\n    > * 没有特别附加权限，等同普通合伙人权益；\n    > * ~~违约？ 什么约？~~\n 4. 执行事务合伙人的除名条件和更换程序；\n    > 不会更换，除非散货\n 5. 有限合伙人入伙、退伙的条件、程序以及相关责任；\n    > 参照婚姻法中离婚的相关条款\n 6. 有限合伙人和普通合伙人相互转变程序。\n    > 合伙人角色不会发生变化\n\n## 如何经营家庭有限合伙企业\n### 目标驱动\n    以目标驱动企业日常运营\n * 目标设定   \n    ![目标](/images/目标.jpeg)\n * 企业目标和个人目标的平衡\n    > 1.\n    > 2. \n * 根据目标推导出的个人计划\n    > 1. \n    > 2. \n \n### 预算式财政（待详细）\n * 保险\n * 风险资金\n * 房租\n * 老婆护肤品\n * 老婆衣服\n * 生活费\n * 旅游\n","source":"_posts/operate-family-like-a-company.md","raw":"---\ntitle: 以企业的方式经营家庭\ndate: 2018-03-17 17:16:15\ncategories: \n- BetterLife\ntags:\n- strategy\n---\n## 想法的产生\n16年看着《管理的实践》却不知道何为公司；认识老婆后便萌生了以企业的方式经营家庭的想法。想着\"以企业的方式经营家庭\"可以\n > * 促使我去了解\"企业\"到底是什么，为以后的创业做铺垫\n > * 目标管理的实践：家庭目标 & 个人目标的平衡\n > * 从一个人变成了一家人，从而必须以组织的角度重新审视\"家\"\n > * 摆脱浑浑噩噩\n \n最近又重新饱受焦虑的困扰，所以迫使着重新梳理了下目标；再加上和老婆生活上的小摩擦让我坚定了这一想法，决定立即实施。\n \n## 家庭企业的建立\n### 家庭适用**有限合伙企业**\n    从下图中可以很快发现，\"有限合伙企业\"和\"家庭\"最贴切（夫妻双方为普通合伙人，父母孩子皆为有限合伙人）。\n \n ![企业类型](/images/企业类型.png)\n### 有限合伙企业成员的角色、权利、义务 \n * 夫妻，普通合伙人，以预算的方式分配企业所得，承担**无限连带责任**\n * 父母，有限合伙人，参与固定分红以及分享一定应急资金，承担有限责任（带孩子等）\n * 孩子，战略性投资项目（因为没有投入和不承担责任所以不应作为合伙人而存在），享受预算优先权，不承担任何责任\n \n### **合伙协议**，按企业法应包含如下内容：\n 1. 普通合伙人和有限合伙人的姓名或者名称、住所；\n    > 略\n 2. 执行事务合伙人应具备的条件和选择程序；\n    > 夫妻两人皆为执行事务合伙人，投票权完全相同\n 3. 执行事务合伙人权限与违约处理办法；\n    > * 没有特别附加权限，等同普通合伙人权益；\n    > * ~~违约？ 什么约？~~\n 4. 执行事务合伙人的除名条件和更换程序；\n    > 不会更换，除非散货\n 5. 有限合伙人入伙、退伙的条件、程序以及相关责任；\n    > 参照婚姻法中离婚的相关条款\n 6. 有限合伙人和普通合伙人相互转变程序。\n    > 合伙人角色不会发生变化\n\n## 如何经营家庭有限合伙企业\n### 目标驱动\n    以目标驱动企业日常运营\n * 目标设定   \n    ![目标](/images/目标.jpeg)\n * 企业目标和个人目标的平衡\n    > 1.\n    > 2. \n * 根据目标推导出的个人计划\n    > 1. \n    > 2. \n \n### 预算式财政（待详细）\n * 保险\n * 风险资金\n * 房租\n * 老婆护肤品\n * 老婆衣服\n * 生活费\n * 旅游\n","slug":"operate-family-like-a-company","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0b00079t9cor6izyol","content":"<h2 id=\"想法的产生\"><a href=\"#想法的产生\" class=\"headerlink\" title=\"想法的产生\"></a>想法的产生</h2><p>16年看着《管理的实践》却不知道何为公司；认识老婆后便萌生了以企业的方式经营家庭的想法。想着”以企业的方式经营家庭”可以</p>\n<blockquote>\n<ul>\n<li>促使我去了解”企业”到底是什么，为以后的创业做铺垫</li>\n<li>目标管理的实践：家庭目标 &amp; 个人目标的平衡</li>\n<li>从一个人变成了一家人，从而必须以组织的角度重新审视”家”</li>\n<li>摆脱浑浑噩噩</li>\n</ul>\n</blockquote>\n<p>最近又重新饱受焦虑的困扰，所以迫使着重新梳理了下目标；再加上和老婆生活上的小摩擦让我坚定了这一想法，决定立即实施。</p>\n<h2 id=\"家庭企业的建立\"><a href=\"#家庭企业的建立\" class=\"headerlink\" title=\"家庭企业的建立\"></a>家庭企业的建立</h2><h3 id=\"家庭适用有限合伙企业\"><a href=\"#家庭适用有限合伙企业\" class=\"headerlink\" title=\"家庭适用有限合伙企业\"></a>家庭适用<strong>有限合伙企业</strong></h3><pre><code>从下图中可以很快发现，&quot;有限合伙企业&quot;和&quot;家庭&quot;最贴切（夫妻双方为普通合伙人，父母孩子皆为有限合伙人）。\n</code></pre><p> <img src=\"/images/企业类型.png\" alt=\"企业类型\"></p>\n<h3 id=\"有限合伙企业成员的角色、权利、义务\"><a href=\"#有限合伙企业成员的角色、权利、义务\" class=\"headerlink\" title=\"有限合伙企业成员的角色、权利、义务\"></a>有限合伙企业成员的角色、权利、义务</h3><ul>\n<li>夫妻，普通合伙人，以预算的方式分配企业所得，承担<strong>无限连带责任</strong></li>\n<li>父母，有限合伙人，参与固定分红以及分享一定应急资金，承担有限责任（带孩子等）</li>\n<li>孩子，战略性投资项目（因为没有投入和不承担责任所以不应作为合伙人而存在），享受预算优先权，不承担任何责任</li>\n</ul>\n<h3 id=\"合伙协议，按企业法应包含如下内容：\"><a href=\"#合伙协议，按企业法应包含如下内容：\" class=\"headerlink\" title=\"合伙协议，按企业法应包含如下内容：\"></a><strong>合伙协议</strong>，按企业法应包含如下内容：</h3><ol>\n<li>普通合伙人和有限合伙人的姓名或者名称、住所；<blockquote>\n<p>略</p>\n</blockquote>\n</li>\n<li>执行事务合伙人应具备的条件和选择程序；<blockquote>\n<p>夫妻两人皆为执行事务合伙人，投票权完全相同</p>\n</blockquote>\n</li>\n<li>执行事务合伙人权限与违约处理办法；<blockquote>\n<ul>\n<li>没有特别附加权限，等同普通合伙人权益；</li>\n<li><del>违约？ 什么约？</del></li>\n</ul>\n</blockquote>\n</li>\n<li>执行事务合伙人的除名条件和更换程序；<blockquote>\n<p>不会更换，除非散货</p>\n</blockquote>\n</li>\n<li>有限合伙人入伙、退伙的条件、程序以及相关责任；<blockquote>\n<p>参照婚姻法中离婚的相关条款</p>\n</blockquote>\n</li>\n<li>有限合伙人和普通合伙人相互转变程序。<blockquote>\n<p>合伙人角色不会发生变化</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"如何经营家庭有限合伙企业\"><a href=\"#如何经营家庭有限合伙企业\" class=\"headerlink\" title=\"如何经营家庭有限合伙企业\"></a>如何经营家庭有限合伙企业</h2><h3 id=\"目标驱动\"><a href=\"#目标驱动\" class=\"headerlink\" title=\"目标驱动\"></a>目标驱动</h3><pre><code>以目标驱动企业日常运营\n</code></pre><ul>\n<li>目标设定<br> <img src=\"/images/目标.jpeg\" alt=\"目标\"></li>\n<li>企业目标和个人目标的平衡<blockquote>\n<p>1.<br>2. </p>\n</blockquote>\n</li>\n<li>根据目标推导出的个人计划<blockquote>\n<ol>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"预算式财政（待详细）\"><a href=\"#预算式财政（待详细）\" class=\"headerlink\" title=\"预算式财政（待详细）\"></a>预算式财政（待详细）</h3><ul>\n<li>保险</li>\n<li>风险资金</li>\n<li>房租</li>\n<li>老婆护肤品</li>\n<li>老婆衣服</li>\n<li>生活费</li>\n<li>旅游</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"想法的产生\"><a href=\"#想法的产生\" class=\"headerlink\" title=\"想法的产生\"></a>想法的产生</h2><p>16年看着《管理的实践》却不知道何为公司；认识老婆后便萌生了以企业的方式经营家庭的想法。想着”以企业的方式经营家庭”可以</p>\n<blockquote>\n<ul>\n<li>促使我去了解”企业”到底是什么，为以后的创业做铺垫</li>\n<li>目标管理的实践：家庭目标 &amp; 个人目标的平衡</li>\n<li>从一个人变成了一家人，从而必须以组织的角度重新审视”家”</li>\n<li>摆脱浑浑噩噩</li>\n</ul>\n</blockquote>\n<p>最近又重新饱受焦虑的困扰，所以迫使着重新梳理了下目标；再加上和老婆生活上的小摩擦让我坚定了这一想法，决定立即实施。</p>\n<h2 id=\"家庭企业的建立\"><a href=\"#家庭企业的建立\" class=\"headerlink\" title=\"家庭企业的建立\"></a>家庭企业的建立</h2><h3 id=\"家庭适用有限合伙企业\"><a href=\"#家庭适用有限合伙企业\" class=\"headerlink\" title=\"家庭适用有限合伙企业\"></a>家庭适用<strong>有限合伙企业</strong></h3><pre><code>从下图中可以很快发现，&quot;有限合伙企业&quot;和&quot;家庭&quot;最贴切（夫妻双方为普通合伙人，父母孩子皆为有限合伙人）。\n</code></pre><p> <img src=\"/images/企业类型.png\" alt=\"企业类型\"></p>\n<h3 id=\"有限合伙企业成员的角色、权利、义务\"><a href=\"#有限合伙企业成员的角色、权利、义务\" class=\"headerlink\" title=\"有限合伙企业成员的角色、权利、义务\"></a>有限合伙企业成员的角色、权利、义务</h3><ul>\n<li>夫妻，普通合伙人，以预算的方式分配企业所得，承担<strong>无限连带责任</strong></li>\n<li>父母，有限合伙人，参与固定分红以及分享一定应急资金，承担有限责任（带孩子等）</li>\n<li>孩子，战略性投资项目（因为没有投入和不承担责任所以不应作为合伙人而存在），享受预算优先权，不承担任何责任</li>\n</ul>\n<h3 id=\"合伙协议，按企业法应包含如下内容：\"><a href=\"#合伙协议，按企业法应包含如下内容：\" class=\"headerlink\" title=\"合伙协议，按企业法应包含如下内容：\"></a><strong>合伙协议</strong>，按企业法应包含如下内容：</h3><ol>\n<li>普通合伙人和有限合伙人的姓名或者名称、住所；<blockquote>\n<p>略</p>\n</blockquote>\n</li>\n<li>执行事务合伙人应具备的条件和选择程序；<blockquote>\n<p>夫妻两人皆为执行事务合伙人，投票权完全相同</p>\n</blockquote>\n</li>\n<li>执行事务合伙人权限与违约处理办法；<blockquote>\n<ul>\n<li>没有特别附加权限，等同普通合伙人权益；</li>\n<li><del>违约？ 什么约？</del></li>\n</ul>\n</blockquote>\n</li>\n<li>执行事务合伙人的除名条件和更换程序；<blockquote>\n<p>不会更换，除非散货</p>\n</blockquote>\n</li>\n<li>有限合伙人入伙、退伙的条件、程序以及相关责任；<blockquote>\n<p>参照婚姻法中离婚的相关条款</p>\n</blockquote>\n</li>\n<li>有限合伙人和普通合伙人相互转变程序。<blockquote>\n<p>合伙人角色不会发生变化</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"如何经营家庭有限合伙企业\"><a href=\"#如何经营家庭有限合伙企业\" class=\"headerlink\" title=\"如何经营家庭有限合伙企业\"></a>如何经营家庭有限合伙企业</h2><h3 id=\"目标驱动\"><a href=\"#目标驱动\" class=\"headerlink\" title=\"目标驱动\"></a>目标驱动</h3><pre><code>以目标驱动企业日常运营\n</code></pre><ul>\n<li>目标设定<br> <img src=\"/images/目标.jpeg\" alt=\"目标\"></li>\n<li>企业目标和个人目标的平衡<blockquote>\n<p>1.<br>2. </p>\n</blockquote>\n</li>\n<li>根据目标推导出的个人计划<blockquote>\n<ol>\n<li></li>\n<li></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"预算式财政（待详细）\"><a href=\"#预算式财政（待详细）\" class=\"headerlink\" title=\"预算式财政（待详细）\"></a>预算式财政（待详细）</h3><ul>\n<li>保险</li>\n<li>风险资金</li>\n<li>房租</li>\n<li>老婆护肤品</li>\n<li>老婆衣服</li>\n<li>生活费</li>\n<li>旅游</li>\n</ul>\n"},{"title":"为什么需要消息中间件 以及 消息中间件的使用场景","date":"2018-03-12T16:00:00.000Z","_content":"## 生产者消费者模式的思考\n- 如何多机器部署运行  <分布式>？\n    >挑战：queue无法跨JVM共享\n- 如何灾备以及负载均衡？\n    >挑战：需要一个controller做通知和分发数据\n\n- 所以，需要一个独立部署的可以被多方访问的服务，其数据必须是多线程乃至分布式安全的\n    消息中间件是个好的选择\n![消息总线图](/images/消息总线.jpg)\n\n## 消息中间件的特征\n- queues （消息的容器）\n- 发布/订阅（Publisher/Subscribe） （发布者发布1条数据，会被多个订阅者消费）\n    >将增量式更新数据推给各个订阅的client，并保证每个client都收到\n    \n    >将数据平均发送给每个订阅者（负载均衡，例如：RocketMQ的CLUSTERING消息模型）\n- P2P（Peer-to-Peer） （1条消息只会被消费一次）\n<!--more-->\n## 对消息中间件的一般要求\n    服务的高可用性（主从或者分布式）\n    消息的低延迟、极少量丢失或不丢失\n\n## 对消息中间件的进一步要求：\n    消息不重复\n    支持事务\n    负载均衡\n\n## 应用场景\n\n### 异步\n    将传统线性程序，转为并发分布式\n    \n* 传统线性做法：\n        1. 动作一\n        2. 动作二\n* 利用消息中间件，并发处理。（发送一个订阅消息，然后由各个消费者并行处理）\n    * consumer1：动作一 （只需保证动作一最终一定成功便可，不关心时效性）\n    * consumer2：动作二\n\n### 解耦\n    在新增功能点时，无需更改主流程代码或逻辑\n    \n* 如果要在动作二后增加动作三，只需再增加相应的订阅者，无需更改主流程\n    * consumer3：发送短信通知下单者支付成功。\n* 把支付、退款从hotel移到到wfinance中统一管理\n\n### 负载均衡\n* 多个consumer分布在多个不同的机器上，热部署.如rocketMQ的集群模式\n    >consumer.setMessageModel(MessageModel.CLUSTERING);\n\n### 防治消息洪流\n* 要求消息中间件有以下两个能力\n    >强有力的消息堆积\n    \n    >持久化\n* 消息队列可以作为 缓冲区域 存在\n* 实例见下文的 日志收集 案例\n\n### push数据\n    场景描述：各个client每10分钟请求一次我们的API，以获取我们的增量数据\n\n### 日志收集\n1. Kafka：接收用户日志的消息队列。\nKafka可以快速接收所有收集过来的日志，并提供堆积和持久化功能，以便Logstash等后续消费者慢慢处理。\n2. Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n3. Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n4. Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n![日志收集架构图](/images/日志收集架构图.png)\n\n## References :\n* [系统间通信系列博文](http://blog.csdn.net/column/details/sys-communication.html)\n* [RocketMQ简介及安装](http://blog.csdn.net/df_xiao/article/details/50522476)\n* [消息队列的使用场景](http://www.cnblogs.com/mxmbk/articles/6598126.html)","source":"_posts/mq-why-and-where-to-use-it.md","raw":"---\ntitle: 为什么需要消息中间件 以及 消息中间件的使用场景\ndate: 2018-03-13\ncategories: \n- MQ\ntags:\n- MQ\n---\n## 生产者消费者模式的思考\n- 如何多机器部署运行  <分布式>？\n    >挑战：queue无法跨JVM共享\n- 如何灾备以及负载均衡？\n    >挑战：需要一个controller做通知和分发数据\n\n- 所以，需要一个独立部署的可以被多方访问的服务，其数据必须是多线程乃至分布式安全的\n    消息中间件是个好的选择\n![消息总线图](/images/消息总线.jpg)\n\n## 消息中间件的特征\n- queues （消息的容器）\n- 发布/订阅（Publisher/Subscribe） （发布者发布1条数据，会被多个订阅者消费）\n    >将增量式更新数据推给各个订阅的client，并保证每个client都收到\n    \n    >将数据平均发送给每个订阅者（负载均衡，例如：RocketMQ的CLUSTERING消息模型）\n- P2P（Peer-to-Peer） （1条消息只会被消费一次）\n<!--more-->\n## 对消息中间件的一般要求\n    服务的高可用性（主从或者分布式）\n    消息的低延迟、极少量丢失或不丢失\n\n## 对消息中间件的进一步要求：\n    消息不重复\n    支持事务\n    负载均衡\n\n## 应用场景\n\n### 异步\n    将传统线性程序，转为并发分布式\n    \n* 传统线性做法：\n        1. 动作一\n        2. 动作二\n* 利用消息中间件，并发处理。（发送一个订阅消息，然后由各个消费者并行处理）\n    * consumer1：动作一 （只需保证动作一最终一定成功便可，不关心时效性）\n    * consumer2：动作二\n\n### 解耦\n    在新增功能点时，无需更改主流程代码或逻辑\n    \n* 如果要在动作二后增加动作三，只需再增加相应的订阅者，无需更改主流程\n    * consumer3：发送短信通知下单者支付成功。\n* 把支付、退款从hotel移到到wfinance中统一管理\n\n### 负载均衡\n* 多个consumer分布在多个不同的机器上，热部署.如rocketMQ的集群模式\n    >consumer.setMessageModel(MessageModel.CLUSTERING);\n\n### 防治消息洪流\n* 要求消息中间件有以下两个能力\n    >强有力的消息堆积\n    \n    >持久化\n* 消息队列可以作为 缓冲区域 存在\n* 实例见下文的 日志收集 案例\n\n### push数据\n    场景描述：各个client每10分钟请求一次我们的API，以获取我们的增量数据\n\n### 日志收集\n1. Kafka：接收用户日志的消息队列。\nKafka可以快速接收所有收集过来的日志，并提供堆积和持久化功能，以便Logstash等后续消费者慢慢处理。\n2. Logstash：做日志解析，统一成JSON输出给Elasticsearch。\n3. Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。\n4. Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。\n![日志收集架构图](/images/日志收集架构图.png)\n\n## References :\n* [系统间通信系列博文](http://blog.csdn.net/column/details/sys-communication.html)\n* [RocketMQ简介及安装](http://blog.csdn.net/df_xiao/article/details/50522476)\n* [消息队列的使用场景](http://www.cnblogs.com/mxmbk/articles/6598126.html)","slug":"mq-why-and-where-to-use-it","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0c00089t9c85yxhg6f","content":"<h2 id=\"生产者消费者模式的思考\"><a href=\"#生产者消费者模式的思考\" class=\"headerlink\" title=\"生产者消费者模式的思考\"></a>生产者消费者模式的思考</h2><ul>\n<li>如何多机器部署运行  &lt;分布式&gt;？<blockquote>\n<p>挑战：queue无法跨JVM共享</p>\n</blockquote>\n</li>\n<li><p>如何灾备以及负载均衡？</p>\n<blockquote>\n<p>挑战：需要一个controller做通知和分发数据</p>\n</blockquote>\n</li>\n<li><p>所以，需要一个独立部署的可以被多方访问的服务，其数据必须是多线程乃至分布式安全的<br>  消息中间件是个好的选择<br><img src=\"/images/消息总线.jpg\" alt=\"消息总线图\"></p>\n</li>\n</ul>\n<h2 id=\"消息中间件的特征\"><a href=\"#消息中间件的特征\" class=\"headerlink\" title=\"消息中间件的特征\"></a>消息中间件的特征</h2><ul>\n<li>queues （消息的容器）</li>\n<li><p>发布/订阅（Publisher/Subscribe） （发布者发布1条数据，会被多个订阅者消费）</p>\n<blockquote>\n<p>将增量式更新数据推给各个订阅的client，并保证每个client都收到</p>\n</blockquote>\n<blockquote>\n<p>将数据平均发送给每个订阅者（负载均衡，例如：RocketMQ的CLUSTERING消息模型）</p>\n</blockquote>\n</li>\n<li>P2P（Peer-to-Peer） （1条消息只会被消费一次）<a id=\"more\"></a>\n<h2 id=\"对消息中间件的一般要求\"><a href=\"#对消息中间件的一般要求\" class=\"headerlink\" title=\"对消息中间件的一般要求\"></a>对消息中间件的一般要求</h2>  服务的高可用性（主从或者分布式）<br>  消息的低延迟、极少量丢失或不丢失</li>\n</ul>\n<h2 id=\"对消息中间件的进一步要求：\"><a href=\"#对消息中间件的进一步要求：\" class=\"headerlink\" title=\"对消息中间件的进一步要求：\"></a>对消息中间件的进一步要求：</h2><pre><code>消息不重复\n支持事务\n负载均衡\n</code></pre><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><pre><code>将传统线性程序，转为并发分布式\n</code></pre><ul>\n<li>传统线性做法：<pre><code>1. 动作一\n2. 动作二\n</code></pre></li>\n<li>利用消息中间件，并发处理。（发送一个订阅消息，然后由各个消费者并行处理）<ul>\n<li>consumer1：动作一 （只需保证动作一最终一定成功便可，不关心时效性）</li>\n<li>consumer2：动作二</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解耦\"><a href=\"#解耦\" class=\"headerlink\" title=\"解耦\"></a>解耦</h3><pre><code>在新增功能点时，无需更改主流程代码或逻辑\n</code></pre><ul>\n<li>如果要在动作二后增加动作三，只需再增加相应的订阅者，无需更改主流程<ul>\n<li>consumer3：发送短信通知下单者支付成功。</li>\n</ul>\n</li>\n<li>把支付、退款从hotel移到到wfinance中统一管理</li>\n</ul>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><ul>\n<li>多个consumer分布在多个不同的机器上，热部署.如rocketMQ的集群模式<blockquote>\n<p>consumer.setMessageModel(MessageModel.CLUSTERING);</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"防治消息洪流\"><a href=\"#防治消息洪流\" class=\"headerlink\" title=\"防治消息洪流\"></a>防治消息洪流</h3><ul>\n<li><p>要求消息中间件有以下两个能力</p>\n<blockquote>\n<p>强有力的消息堆积</p>\n</blockquote>\n<blockquote>\n<p>持久化</p>\n</blockquote>\n</li>\n<li>消息队列可以作为 缓冲区域 存在</li>\n<li>实例见下文的 日志收集 案例</li>\n</ul>\n<h3 id=\"push数据\"><a href=\"#push数据\" class=\"headerlink\" title=\"push数据\"></a>push数据</h3><pre><code>场景描述：各个client每10分钟请求一次我们的API，以获取我们的增量数据\n</code></pre><h3 id=\"日志收集\"><a href=\"#日志收集\" class=\"headerlink\" title=\"日志收集\"></a>日志收集</h3><ol>\n<li>Kafka：接收用户日志的消息队列。<br>Kafka可以快速接收所有收集过来的日志，并提供堆积和持久化功能，以便Logstash等后续消费者慢慢处理。</li>\n<li>Logstash：做日志解析，统一成JSON输出给Elasticsearch。</li>\n<li>Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li>\n<li>Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。<br><img src=\"/images/日志收集架构图.png\" alt=\"日志收集架构图\"></li>\n</ol>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References :\"></a>References :</h2><ul>\n<li><a href=\"http://blog.csdn.net/column/details/sys-communication.html\" target=\"_blank\" rel=\"noopener\">系统间通信系列博文</a></li>\n<li><a href=\"http://blog.csdn.net/df_xiao/article/details/50522476\" target=\"_blank\" rel=\"noopener\">RocketMQ简介及安装</a></li>\n<li><a href=\"http://www.cnblogs.com/mxmbk/articles/6598126.html\" target=\"_blank\" rel=\"noopener\">消息队列的使用场景</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"生产者消费者模式的思考\"><a href=\"#生产者消费者模式的思考\" class=\"headerlink\" title=\"生产者消费者模式的思考\"></a>生产者消费者模式的思考</h2><ul>\n<li>如何多机器部署运行  &lt;分布式&gt;？<blockquote>\n<p>挑战：queue无法跨JVM共享</p>\n</blockquote>\n</li>\n<li><p>如何灾备以及负载均衡？</p>\n<blockquote>\n<p>挑战：需要一个controller做通知和分发数据</p>\n</blockquote>\n</li>\n<li><p>所以，需要一个独立部署的可以被多方访问的服务，其数据必须是多线程乃至分布式安全的<br>  消息中间件是个好的选择<br><img src=\"/images/消息总线.jpg\" alt=\"消息总线图\"></p>\n</li>\n</ul>\n<h2 id=\"消息中间件的特征\"><a href=\"#消息中间件的特征\" class=\"headerlink\" title=\"消息中间件的特征\"></a>消息中间件的特征</h2><ul>\n<li>queues （消息的容器）</li>\n<li><p>发布/订阅（Publisher/Subscribe） （发布者发布1条数据，会被多个订阅者消费）</p>\n<blockquote>\n<p>将增量式更新数据推给各个订阅的client，并保证每个client都收到</p>\n</blockquote>\n<blockquote>\n<p>将数据平均发送给每个订阅者（负载均衡，例如：RocketMQ的CLUSTERING消息模型）</p>\n</blockquote>\n</li>\n<li>P2P（Peer-to-Peer） （1条消息只会被消费一次）","more":"<h2 id=\"对消息中间件的一般要求\"><a href=\"#对消息中间件的一般要求\" class=\"headerlink\" title=\"对消息中间件的一般要求\"></a>对消息中间件的一般要求</h2>  服务的高可用性（主从或者分布式）<br>  消息的低延迟、极少量丢失或不丢失</li>\n</ul>\n<h2 id=\"对消息中间件的进一步要求：\"><a href=\"#对消息中间件的进一步要求：\" class=\"headerlink\" title=\"对消息中间件的进一步要求：\"></a>对消息中间件的进一步要求：</h2><pre><code>消息不重复\n支持事务\n负载均衡\n</code></pre><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h3 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h3><pre><code>将传统线性程序，转为并发分布式\n</code></pre><ul>\n<li>传统线性做法：<pre><code>1. 动作一\n2. 动作二\n</code></pre></li>\n<li>利用消息中间件，并发处理。（发送一个订阅消息，然后由各个消费者并行处理）<ul>\n<li>consumer1：动作一 （只需保证动作一最终一定成功便可，不关心时效性）</li>\n<li>consumer2：动作二</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"解耦\"><a href=\"#解耦\" class=\"headerlink\" title=\"解耦\"></a>解耦</h3><pre><code>在新增功能点时，无需更改主流程代码或逻辑\n</code></pre><ul>\n<li>如果要在动作二后增加动作三，只需再增加相应的订阅者，无需更改主流程<ul>\n<li>consumer3：发送短信通知下单者支付成功。</li>\n</ul>\n</li>\n<li>把支付、退款从hotel移到到wfinance中统一管理</li>\n</ul>\n<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><ul>\n<li>多个consumer分布在多个不同的机器上，热部署.如rocketMQ的集群模式<blockquote>\n<p>consumer.setMessageModel(MessageModel.CLUSTERING);</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"防治消息洪流\"><a href=\"#防治消息洪流\" class=\"headerlink\" title=\"防治消息洪流\"></a>防治消息洪流</h3><ul>\n<li><p>要求消息中间件有以下两个能力</p>\n<blockquote>\n<p>强有力的消息堆积</p>\n</blockquote>\n<blockquote>\n<p>持久化</p>\n</blockquote>\n</li>\n<li>消息队列可以作为 缓冲区域 存在</li>\n<li>实例见下文的 日志收集 案例</li>\n</ul>\n<h3 id=\"push数据\"><a href=\"#push数据\" class=\"headerlink\" title=\"push数据\"></a>push数据</h3><pre><code>场景描述：各个client每10分钟请求一次我们的API，以获取我们的增量数据\n</code></pre><h3 id=\"日志收集\"><a href=\"#日志收集\" class=\"headerlink\" title=\"日志收集\"></a>日志收集</h3><ol>\n<li>Kafka：接收用户日志的消息队列。<br>Kafka可以快速接收所有收集过来的日志，并提供堆积和持久化功能，以便Logstash等后续消费者慢慢处理。</li>\n<li>Logstash：做日志解析，统一成JSON输出给Elasticsearch。</li>\n<li>Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。</li>\n<li>Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。<br><img src=\"/images/日志收集架构图.png\" alt=\"日志收集架构图\"></li>\n</ol>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References :\"></a>References :</h2><ul>\n<li><a href=\"http://blog.csdn.net/column/details/sys-communication.html\" target=\"_blank\" rel=\"noopener\">系统间通信系列博文</a></li>\n<li><a href=\"http://blog.csdn.net/df_xiao/article/details/50522476\" target=\"_blank\" rel=\"noopener\">RocketMQ简介及安装</a></li>\n<li><a href=\"http://www.cnblogs.com/mxmbk/articles/6598126.html\" target=\"_blank\" rel=\"noopener\">消息队列的使用场景</a></li>\n</ul>"},{"title":"HashMap的工作原理【译文】","date":"2018-03-14T16:00:00.000Z","_content":">翻译自[How does a HashMap work in JAVA - Coding Geek](http://coding-geek.com/how-does-a-hashmap-work-in-java/).\n欢迎指正错误。\n\n绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？\n最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashMap的源码， 先是基于java 7然后java 8。\n在这篇博文里，我将为大家展示HashMap的实现原理，在java 8中的新特性在使用中要注意的关于性能和内存的问题，以及一些常见问题。\n\n###### Contents\n>1. 内部存储\n>2. 自适应大小\n>3. 线程安全\n>4. Key的不可变性\n>5. JAVA 8中的提升\n>6. 内存负载\n>   1. JAVA 7\n>   2. JAVA 8\n>7 性能问题\n>   1. Skewed HashMap vs well balanced HashMap\n>   2. 自适应大小带来的开销\n>8 总结\n \n<!--more-->\n\n### Internal storage\nHashMap的接口是Map<K,V>，这个接口的主要方法有：\n>* V put(K key, V value)\n>* V get(Object key)\n>* V remove(Object key)\n>* Boolean containsKey(Object key)\n\nHashMap真正存储数据的地方是其内部类：Entry<K, V>, 就是一个简单的键值对外加两个property：\n>* 指向另一个Entry的引用，从而使HashMap可以像LinkedList一样存储多个实体\n>* key的hash值，从而避免每次使用时都要重复计算其hash值\n\n下面是Entry在JAVA 7中的部分代码：\n``` java\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n…\n}\n```\nHashMap将数据存储在多个链表中（也称为**分桶**或分箱），所有的链表又都保存在一个Entry数组中（数组的默认容量为**16**）。\n\nThe following picture shows the inner storage \nof a HashMap instance with an array of nullable entries. \nEach Entry can link to another Entry to form a linked list.\n下面这张图展示了一个HashMap实例的内部存储结构 - 一个支持null节点的数组。\n![internal_storage](/images/internal_storage_java_hashmap.jpg)\n \n\n\n \n\nAll the keys with the same hash value are put in the same linked list (bucket). Keys with different hash values can end-up in the same bucket.\n\nWhen a user calls put(K key, V value) or get(Object key), the function computes the index of the bucket in which the Entry should be. Then, the function iterates through the list to look for the Entry that has the same key (using the equals() function of the key).\n\nIn the case of the get(), the function returns the value associated with the entry (if the entry exists).\n\nIn the case of the put(K key, V value), if the entry exists the function replaces it with the new value otherwise it creates a new entry (from the key and value in arguments) at the head of the singly linked list.\n\n \n\nThis index of the bucket (linked list) is generated in 3 steps by the map:\n\nIt first gets the hashcode of the key.\nIt rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array\nIt takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.\nHere is the JAVA 7 and 8 source code that deals with the index:\n\n// the \"rehash\" function in JAVA 7 that takes the hashcode of the key\nstatic int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// the \"rehash\" function in JAVA 8 that directly takes the key\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n// the function that returns the index from the rehashed hash\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\nIn order to work efficiently, the size of the inner array needs to be a power of 2, let’s see why.\n\nImagine the array size is 17, the mask value is going to be 16 (size -1). The binary representation of 16 is 0…010000, so for any hash value H the index generated with the bitwise formula “H AND 16” is going to be either 16 or 0. This means that the array of size 17 will only be used for 2 buckets: the one at index 0 and the one at index 16, not very efficient…\n\nBut, if you now take a size that is a power of 2 like 16, the bitwise index formula is “H AND 15”. The binary representation of 15 is 0…001111 so the index formula can output values from 0 to 15 and the array of size 16 is fully used. For example:\n\nif H = 952 , its binary representation is 0..01110111000, the associated index is 0…01000 = 8\nif H = 1576 its binary representation is 0..011000101000, the associated index is  0…01000 = 8\nif H = 12356146, its binary representation is 0..0101111001000101000110010, the associated index is 0…00010 = 2\nif H = 59843, its binary representation is 0..01110100111000011, the associated index is 0…00011 = 3\n \n\nThis is why the array size is a power of two. This mechanism is transparent for the developer: if he chooses a HashMap with a size of 37, the Map will automatically choose the next power of 2 after 37 (64) for the size of its inner array.\n\n \n\nAuto resizing\nAfter getting the index, the function (get, put or remove) visits/iterates the associated linked list to see if there is an existing Entry for the given key. Without modification, this mechanism could lead to performance issues because the function needs to iterate through the entire list to see if the entry exists. Imagine that the size of the inner array is the default value (16) and you need to store 2 millions values. In the best case scenario, each linked list will have a size of 125 000 entries (2/16 millions). So, each get(), remove() and put() will lead to 125 000 iterations/operations. To avoid this case, the HashMap has the ability to increase its inner array in order to keep very short linked lists.\n\nWhen you create a HashMap, you can specify an initial size and a loadFactor with the following constructor:\n\npublic HashMap(int initialCapacity, float loadFactor)\nIf you don’t specify arguments, the default initialCapacity is 16 and the default loadFactor is 0.75. The initialCapacity represents to the size of the inner array of linked lists.\n\nEach time you add a new key/value in your Map with put(…), the function checks if it needs to increase the capacity of the inner array. In order to do that, the map stores 2 data:\n\nThe size of the map: it represents the number of entries in the HashMap. This value is updated each time an Entry is added or removed.\nA threshold: it’s equal to (capacity of the inner array) * loadFactor and it is refreshed after each resize of the inner array\nBefore adding the new Entry, put(…) checks if size > threshold and if it the case it recreates a new array with a doubled size. Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes. So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets (the old ones and the newly created).\n\nThis aim of this resize operation is to decrease the size of the linked lists so that the time cost of put(), remove() and get() methods stays low. All entries whose keys have the same hash will stay in the same bucket after the resizing. But, 2 entries with different hash keys that were in the same bucket before might not be in the same bucket after the transformation.\n\nresizing_of_java_hashmap\n\nThe picture shows a representation before and after the resizing of the inner array. Before the increase, in order to get Entry E, the map had to iterate through a list of 5 elements. After the resizing, the same get() just iterates through a linked list of 2 elements, the get() is 2 times faster after the resizing !\n\n \n\nNote: the HashMap only increases the size of the inner array, it doesn’t provide a way to decrease it.\n\n \n\nThread Safety\nIf you already know HashMaps, you know that is not threads safe, but why? For example imagine that you have a Writer thread that puts only new data into the Map and a Reader thread that reads data from the Map, why shouldn’t it work?\n\nBecause during the auto-resizing mechanism, if a thread tries to put or get an object, the map might use the old index value and won’t find the new bucket in which the entry is.\n\nThe worst case scenario is when 2 threads put a data at the same time and the 2 put() calls resize the Map at the same time. Since both threads modify the linked lists at the same time, the Map might end up with an inner-loop in one of its linked lists. If you tries to get a data in the list with an inner loop, the get() will never end.\n\nThe HashTable implementation is a thread safe implementation that prevents from this situation. But, since all the CRUD methods are synchronized this implementation is very slow. For example, if thread 1 calls get(key1), thread 2 calls get(key2) and thread 3 calls get(key3), only one thread at a time will be able to get its value whereas the 3 of them could access the data at the same time.\n\nA smarter implementation of a thread safe HashMap exists since JAVA 5: the ConcurrentHashMap. Only the buckets are synchronized so multiples threads can get(), remove() or put() data at the same time if it doesn’t imply accessing the same bucket or resizing the inner array. It’s better to use this implementation in a multithreaded application.\n\n \n\nKey immutability\nWhy Strings and Integers are a good implementation of keys for HashMap? Mostly because they are immutable! If you choose to create your own Key class and don’t make it immutable, you might lose data inside the HashMap.\n\nLook at the following use case:\n\nYou have a key that has an inner value “1”\nYou put an object in the HashMap with this key\nThe HashMap generates a hash from the hashcode of the Key (so from “1”)\nThe Map  stores this hash in the newly created Entry\nYou modify the inner value of the key to “2”\nThe hash value of the key is modified but the HashMap doesn’t know it (because the old hash value is stored)\nYou try to get your object with your modified key\nThe map computes the new hash of your key (so from “2”) to find in which linked list (bucket) the entry is\nCase 1: Since you modified your key, the map tries to find the entry in the wrong bucket and doesn’t find it\n Case 2: Luckily, the modified key generates the same bucket as the old key. The map then iterates through the linked list to find the entry with the same key. But to find the key, the map first compares the hash values and then calls the equals() comparison. Since your modified key doesn’t have the same hash as the old hash value (stored in the entry), the map won’t find the entry in the linked-list.\nHere is a concrete example in Java. I put 2 key-value pairs in my Map, I modify the first key and then try to get the 2 values. Only the second value is returned from the map, the first value is “lost” in the HashMap:\n\npublic class MutableKeyTest {\n \n    public static void main(String[] args) {\n \n        class MyKey {\n            Integer i;\n \n            public void setI(Integer i) {\n                this.i = i;\n            }\n \n            public MyKey(Integer i) {\n                this.i = i;\n            }\n \n            @Override\n            public int hashCode() {\n                return i;\n            }\n \n            @Override\n            public boolean equals(Object obj) {\n                if (obj instanceof MyKey) {\n                    return i.equals(((MyKey) obj).i);\n                } else\n                    return false;\n            }\n \n        }\n \n        Map<MyKey, String> myMap = new HashMap<>();\n        MyKey key1 = new MyKey(1);\n        MyKey key2 = new MyKey(2);\n \n        myMap.put(key1, \"test \" + 1);\n        myMap.put(key2, \"test \" + 2);\n \n        // modifying key1\n        key1.setI(3);\n \n        String test1 = myMap.get(key1);\n        String test2 = myMap.get(key2);\n \n        System.out.println(\"test1= \" + test1 + \" test2=\" + test2);\n \n    }\n \n}\nThe output is: “test1= null test2=test 2”. As expected, the Map wasn’t able to retrieve the string 1 with the modified key 1.\n\n \n\nJAVA 8 improvements\nThe inner representation of the HashMap has changed a lot in JAVA 8. Indeed, the implementation in JAVA 7 takes 1k lines of code whereas the implementation in JAVA 8 takes 2k lines. Most of what I’ve said previously is true except the linked lists of entries. In JAVA8, you still have an array but it now stores Nodes that contains the exact same information as Entries and therefore are also linked lists:\n\nHere is a part of the Node implementation in JAVA 8:\n\nstatic class Node<K,V> implements Map.Entry<K,V> {\n     final int hash;\n     final K key;\n     V value;\n     Node<K,V> next;\nSo what’s the big difference with JAVA 7? Well, Nodes can be extended to TreeNodes. A TreeNode is a red-black tree structure that stores really more information so that it can add, delete or get an element in O(log(n)).\n\nFYI, here is the exhaustive list of the data stored inside a TreeNode\n\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    final int hash; // inherited from Node<K,V>\n    final K key; // inherited from Node<K,V>\n    V value; // inherited from Node<K,V>\n    Node<K,V> next; // inherited from Node<K,V>\n    Entry<K,V> before, after;// inherited from LinkedHashMap.Entry<K,V>\n    TreeNode<K,V> parent;\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;\n    boolean red;\nRed black trees are self-balancing binary search trees. Their inner mechanisms ensure that their length is always in log(n) despite new adds or removes of nodes. The main advantage to use those trees is in a case where many data are in the same index (bucket) of the inner table, the search in a tree will cost O(log(n)) whereas it would have cost O(n) with a linked list.\n\nAs you see, the tree takes really more space than the linked list (we’ll speak about it in the next part).\n\nBy inheritance, the inner table can contain both Node (linked list ) and TreeNode (red-black tree). Oracle decided to use both data structures with the following rules:\n– If for a given index (bucket) in the inner table there are more than 8 nodes, the linked list is transformed into a red black tree\n– If for a given index (bucket) in the inner table there are less than 6 nodes, the tree is transformed into a linked list\n\ninternal_storage_java8_hashmap\n\nThis picture shows an inner array of a JAVA 8 HashMap with both trees (at bucket 0) and linked lists (at bucket 1,2 and 3). Bucket 0 is a Tree because it has more than 8 nodes.\n\n \n\nMemory overhead\nJAVA 7\n\nThe use of a HashMap comes at a cost in terms of memory. In JAVA 7, a HashMap wraps key-value pairs in Entries. An entry has:\n\na reference to a next entry\na precomputed hash (integer)\na reference to the key\na reference to the value\nMoreover, a JAVA 7 HashMap uses an inner array of Entry. Assuming a JAVA 7 HashMap contains N elements and its inner array has a capacity CAPACITY, the extra memory cost is approximately:\n\nsizeOf(integer)* N + sizeOf(reference)* (3*N+C)\n\nWhere:\n\nthe size of an integer depends equals 4 bytes\nthe size of a reference depends on the JVM/OS/Processor but is often 4 bytes.\nWhich means that the overhead is often 16 * N + 4 * CAPACITY bytes\n\nReminder: after an auto-resizing of the Map, the  CAPACITY  of the inner array equals the next power of two after N.\n\nNote: Since JAVA 7, the HashMap class has a lazy init. That means that even if you allocate a HashMap, the inner array of entry (that costs 4 * CAPACITY bytes) won’t be allocated in memory until the first use of the put() method.\n\nJAVA 8\n\nWith the JAVA 8 implementation, it becomes a little bit complicated to get the memory usage because a Node can contain the same data as an Entry or the same data plus 6 references and a Boolean (if it’s a TreeNode).\n\nIf the all the nodes are only Nodes, the memory consumption of the JAVA 8 HashMap is the same as the JAVA 7 HashMap.\n\nIf the all the nodes are TreeNodes, the memory consumption of a JAVA 8 HashMap becomes:\n\nN * sizeOf(integer) + N * sizeOf(boolean) + sizeOf(reference)* (9*N+CAPACITY )\n\nIn most standards JVM, it’s equal to 44 * N + 4 * CAPACITY bytes\n\n \n\nPerformance issues\nSkewed HashMap vs well balanced HashMap\n\nIn the best case scenario, the get() and put() methods have a O(1) cost in time complexity. But, if you don’t take care of the hash function of the key, you might end up with very slow put() and get() calls. The good performance of the put() and get depends on the repartition of the data into the different indexes of the inner array (the buckets). If the hash function of your key is ill-designed, you’ll have a skew repartition (no matter how big the capacity of the inner array is). All the put() and get() that use the biggest linked lists of entry will be slow because they’ll need to iterate the entire lists. In the worst case scenario (if most of the data are in the same buckets), you could end up with a O(n) time complexity.\nHere is a visual example. The first picture shows a skewed HashMap and the second picture a well balanced one.\n\nskewed_java_hashmap\n\n \n\nIn the case of this skewed HashMap the get()/put() operations on the bucket 0 are costly. Getting the Entry K will cost 6 iterations\n\nwell_balanced_java_hashmapIn the case of this well balanced HashMap, getting the Entry K will cost 3 iterations. Both HashMaps store the same amount of data and have the same inner array size. The only difference is the hash (of the key) function that distributes the entries in the buckets.\n\nHere is an extreme example in JAVA where I create a hash function that puts all the data in the same bucket then I add 2 million elements.\n\npublic class Test {\n \n    public static void main(String[] args) {\n \n        class MyKey {\n            Integer i;\n            public MyKey(Integer i){\n                this.i =i;\n            }\n \n            @Override\n            public int hashCode() {\n                return 1;\n            }\n \n            @Override\n            public boolean equals(Object obj) {\n            …\n            }\n \n        }\n        Date begin = new Date();\n        Map <MyKey,String> myMap= new HashMap<>(2_500_000,1);\n        for (int i=0;i<2_000_000;i++){\n            myMap.put( new MyKey(i), \"test \"+i);\n        }\n \n        Date end = new Date();\n        System.out.println(\"Duration (ms) \"+ (end.getTime()-begin.getTime()));\n    }\n}\nOn my core i5-2500k @ 3.6Ghz it takes more than 45 minutes with java 8u40 (I stopped the process after 45 minutes).\n\nNow, If I run the same code but this time I use the following hash function\n\n    @Override\n    public int hashCode() {\n        int key = 2097152-1;\n        return key+2097152*i;\n}\nit takes 46 seconds, which is way better! This hash function has a better repartition than the previous one so the put() calls are faster.\n\nAnd If I run the same code with the following hash function that provides an even better hash repartition\n\n@Override\npublic int hashCode() {\nreturn i;\n}\nit now takes 2 seconds.\n\nI hope you realize how important the hash function is. If a ran the same test on JAVA 7, the results would have been worse for the first and second cases (since the time complexity of put is O(n) in JAVA 7 vs O(log(n)) in JAVA 8)\n\nWhen using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.\n\n \n\nResizing overhead\n\nIf you need to store a lot of data, you should create your HashMap with an initial capacity close to your expected volume.\n\nIf you don’t do that, the Map will take the default size of 16 with a factorLoad of 0.75. The 11 first put() will be very fast but the 12th (16*0.75) will recreate a new inner array (with its associated linked lists/trees) with a new capacity of 32. The 13th to 23th will be fast but the 24th (32*0.75) will recreate (again) a costly new representation that doubles the size of the inner array. The internal resizing operation will appear at the 48th, 96th,192th, … call of put(). At low volume the full recreation of the inner array is fast but at high volume it can takes seconds to minutes. By initially setting your expected size, you can avoid these costly operations.\n\nBut there is a drawback: if you set a very high array size like 2^28 whereas you’re only using 2^26 buckets in your array, you will waste a lot of memory (approximately 2^30 bytes in this case).\n\n \n\nConclusion\nFor simple use cases, you don’t need to know how HashMaps work since you won’t see the difference between a O(1) and a O(n) or O(log(n)) operation. But it’s always better to understand the underlaying mecanism of one of the most used data structures. Moreover, for a java developer position it’s a typical interview question.\n\nAt high volume it becomes important to know how it works and to understand the importance of the hash function of the key.\n\nI hope this article helped you to have a deep understanding of the HashMap implementation.","source":"_posts/how-does-a-hashmap-work-in-java.md","raw":"---\ntitle: HashMap的工作原理【译文】\ndate: 2018-03-15\ncategories: \n- DataStructure\ntags:\n- DataStructure\n- HashMap\n---\n>翻译自[How does a HashMap work in JAVA - Coding Geek](http://coding-geek.com/how-does-a-hashmap-work-in-java/).\n欢迎指正错误。\n\n绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？\n最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashMap的源码， 先是基于java 7然后java 8。\n在这篇博文里，我将为大家展示HashMap的实现原理，在java 8中的新特性在使用中要注意的关于性能和内存的问题，以及一些常见问题。\n\n###### Contents\n>1. 内部存储\n>2. 自适应大小\n>3. 线程安全\n>4. Key的不可变性\n>5. JAVA 8中的提升\n>6. 内存负载\n>   1. JAVA 7\n>   2. JAVA 8\n>7 性能问题\n>   1. Skewed HashMap vs well balanced HashMap\n>   2. 自适应大小带来的开销\n>8 总结\n \n<!--more-->\n\n### Internal storage\nHashMap的接口是Map<K,V>，这个接口的主要方法有：\n>* V put(K key, V value)\n>* V get(Object key)\n>* V remove(Object key)\n>* Boolean containsKey(Object key)\n\nHashMap真正存储数据的地方是其内部类：Entry<K, V>, 就是一个简单的键值对外加两个property：\n>* 指向另一个Entry的引用，从而使HashMap可以像LinkedList一样存储多个实体\n>* key的hash值，从而避免每次使用时都要重复计算其hash值\n\n下面是Entry在JAVA 7中的部分代码：\n``` java\nstatic class Entry<K,V> implements Map.Entry<K,V> {\n        final K key;\n        V value;\n        Entry<K,V> next;\n        int hash;\n…\n}\n```\nHashMap将数据存储在多个链表中（也称为**分桶**或分箱），所有的链表又都保存在一个Entry数组中（数组的默认容量为**16**）。\n\nThe following picture shows the inner storage \nof a HashMap instance with an array of nullable entries. \nEach Entry can link to another Entry to form a linked list.\n下面这张图展示了一个HashMap实例的内部存储结构 - 一个支持null节点的数组。\n![internal_storage](/images/internal_storage_java_hashmap.jpg)\n \n\n\n \n\nAll the keys with the same hash value are put in the same linked list (bucket). Keys with different hash values can end-up in the same bucket.\n\nWhen a user calls put(K key, V value) or get(Object key), the function computes the index of the bucket in which the Entry should be. Then, the function iterates through the list to look for the Entry that has the same key (using the equals() function of the key).\n\nIn the case of the get(), the function returns the value associated with the entry (if the entry exists).\n\nIn the case of the put(K key, V value), if the entry exists the function replaces it with the new value otherwise it creates a new entry (from the key and value in arguments) at the head of the singly linked list.\n\n \n\nThis index of the bucket (linked list) is generated in 3 steps by the map:\n\nIt first gets the hashcode of the key.\nIt rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array\nIt takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.\nHere is the JAVA 7 and 8 source code that deals with the index:\n\n// the \"rehash\" function in JAVA 7 that takes the hashcode of the key\nstatic int hash(int h) {\n    h ^= (h >>> 20) ^ (h >>> 12);\n    return h ^ (h >>> 7) ^ (h >>> 4);\n}\n// the \"rehash\" function in JAVA 8 that directly takes the key\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n// the function that returns the index from the rehashed hash\nstatic int indexFor(int h, int length) {\n    return h & (length-1);\n}\nIn order to work efficiently, the size of the inner array needs to be a power of 2, let’s see why.\n\nImagine the array size is 17, the mask value is going to be 16 (size -1). The binary representation of 16 is 0…010000, so for any hash value H the index generated with the bitwise formula “H AND 16” is going to be either 16 or 0. This means that the array of size 17 will only be used for 2 buckets: the one at index 0 and the one at index 16, not very efficient…\n\nBut, if you now take a size that is a power of 2 like 16, the bitwise index formula is “H AND 15”. The binary representation of 15 is 0…001111 so the index formula can output values from 0 to 15 and the array of size 16 is fully used. For example:\n\nif H = 952 , its binary representation is 0..01110111000, the associated index is 0…01000 = 8\nif H = 1576 its binary representation is 0..011000101000, the associated index is  0…01000 = 8\nif H = 12356146, its binary representation is 0..0101111001000101000110010, the associated index is 0…00010 = 2\nif H = 59843, its binary representation is 0..01110100111000011, the associated index is 0…00011 = 3\n \n\nThis is why the array size is a power of two. This mechanism is transparent for the developer: if he chooses a HashMap with a size of 37, the Map will automatically choose the next power of 2 after 37 (64) for the size of its inner array.\n\n \n\nAuto resizing\nAfter getting the index, the function (get, put or remove) visits/iterates the associated linked list to see if there is an existing Entry for the given key. Without modification, this mechanism could lead to performance issues because the function needs to iterate through the entire list to see if the entry exists. Imagine that the size of the inner array is the default value (16) and you need to store 2 millions values. In the best case scenario, each linked list will have a size of 125 000 entries (2/16 millions). So, each get(), remove() and put() will lead to 125 000 iterations/operations. To avoid this case, the HashMap has the ability to increase its inner array in order to keep very short linked lists.\n\nWhen you create a HashMap, you can specify an initial size and a loadFactor with the following constructor:\n\npublic HashMap(int initialCapacity, float loadFactor)\nIf you don’t specify arguments, the default initialCapacity is 16 and the default loadFactor is 0.75. The initialCapacity represents to the size of the inner array of linked lists.\n\nEach time you add a new key/value in your Map with put(…), the function checks if it needs to increase the capacity of the inner array. In order to do that, the map stores 2 data:\n\nThe size of the map: it represents the number of entries in the HashMap. This value is updated each time an Entry is added or removed.\nA threshold: it’s equal to (capacity of the inner array) * loadFactor and it is refreshed after each resize of the inner array\nBefore adding the new Entry, put(…) checks if size > threshold and if it the case it recreates a new array with a doubled size. Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes. So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets (the old ones and the newly created).\n\nThis aim of this resize operation is to decrease the size of the linked lists so that the time cost of put(), remove() and get() methods stays low. All entries whose keys have the same hash will stay in the same bucket after the resizing. But, 2 entries with different hash keys that were in the same bucket before might not be in the same bucket after the transformation.\n\nresizing_of_java_hashmap\n\nThe picture shows a representation before and after the resizing of the inner array. Before the increase, in order to get Entry E, the map had to iterate through a list of 5 elements. After the resizing, the same get() just iterates through a linked list of 2 elements, the get() is 2 times faster after the resizing !\n\n \n\nNote: the HashMap only increases the size of the inner array, it doesn’t provide a way to decrease it.\n\n \n\nThread Safety\nIf you already know HashMaps, you know that is not threads safe, but why? For example imagine that you have a Writer thread that puts only new data into the Map and a Reader thread that reads data from the Map, why shouldn’t it work?\n\nBecause during the auto-resizing mechanism, if a thread tries to put or get an object, the map might use the old index value and won’t find the new bucket in which the entry is.\n\nThe worst case scenario is when 2 threads put a data at the same time and the 2 put() calls resize the Map at the same time. Since both threads modify the linked lists at the same time, the Map might end up with an inner-loop in one of its linked lists. If you tries to get a data in the list with an inner loop, the get() will never end.\n\nThe HashTable implementation is a thread safe implementation that prevents from this situation. But, since all the CRUD methods are synchronized this implementation is very slow. For example, if thread 1 calls get(key1), thread 2 calls get(key2) and thread 3 calls get(key3), only one thread at a time will be able to get its value whereas the 3 of them could access the data at the same time.\n\nA smarter implementation of a thread safe HashMap exists since JAVA 5: the ConcurrentHashMap. Only the buckets are synchronized so multiples threads can get(), remove() or put() data at the same time if it doesn’t imply accessing the same bucket or resizing the inner array. It’s better to use this implementation in a multithreaded application.\n\n \n\nKey immutability\nWhy Strings and Integers are a good implementation of keys for HashMap? Mostly because they are immutable! If you choose to create your own Key class and don’t make it immutable, you might lose data inside the HashMap.\n\nLook at the following use case:\n\nYou have a key that has an inner value “1”\nYou put an object in the HashMap with this key\nThe HashMap generates a hash from the hashcode of the Key (so from “1”)\nThe Map  stores this hash in the newly created Entry\nYou modify the inner value of the key to “2”\nThe hash value of the key is modified but the HashMap doesn’t know it (because the old hash value is stored)\nYou try to get your object with your modified key\nThe map computes the new hash of your key (so from “2”) to find in which linked list (bucket) the entry is\nCase 1: Since you modified your key, the map tries to find the entry in the wrong bucket and doesn’t find it\n Case 2: Luckily, the modified key generates the same bucket as the old key. The map then iterates through the linked list to find the entry with the same key. But to find the key, the map first compares the hash values and then calls the equals() comparison. Since your modified key doesn’t have the same hash as the old hash value (stored in the entry), the map won’t find the entry in the linked-list.\nHere is a concrete example in Java. I put 2 key-value pairs in my Map, I modify the first key and then try to get the 2 values. Only the second value is returned from the map, the first value is “lost” in the HashMap:\n\npublic class MutableKeyTest {\n \n    public static void main(String[] args) {\n \n        class MyKey {\n            Integer i;\n \n            public void setI(Integer i) {\n                this.i = i;\n            }\n \n            public MyKey(Integer i) {\n                this.i = i;\n            }\n \n            @Override\n            public int hashCode() {\n                return i;\n            }\n \n            @Override\n            public boolean equals(Object obj) {\n                if (obj instanceof MyKey) {\n                    return i.equals(((MyKey) obj).i);\n                } else\n                    return false;\n            }\n \n        }\n \n        Map<MyKey, String> myMap = new HashMap<>();\n        MyKey key1 = new MyKey(1);\n        MyKey key2 = new MyKey(2);\n \n        myMap.put(key1, \"test \" + 1);\n        myMap.put(key2, \"test \" + 2);\n \n        // modifying key1\n        key1.setI(3);\n \n        String test1 = myMap.get(key1);\n        String test2 = myMap.get(key2);\n \n        System.out.println(\"test1= \" + test1 + \" test2=\" + test2);\n \n    }\n \n}\nThe output is: “test1= null test2=test 2”. As expected, the Map wasn’t able to retrieve the string 1 with the modified key 1.\n\n \n\nJAVA 8 improvements\nThe inner representation of the HashMap has changed a lot in JAVA 8. Indeed, the implementation in JAVA 7 takes 1k lines of code whereas the implementation in JAVA 8 takes 2k lines. Most of what I’ve said previously is true except the linked lists of entries. In JAVA8, you still have an array but it now stores Nodes that contains the exact same information as Entries and therefore are also linked lists:\n\nHere is a part of the Node implementation in JAVA 8:\n\nstatic class Node<K,V> implements Map.Entry<K,V> {\n     final int hash;\n     final K key;\n     V value;\n     Node<K,V> next;\nSo what’s the big difference with JAVA 7? Well, Nodes can be extended to TreeNodes. A TreeNode is a red-black tree structure that stores really more information so that it can add, delete or get an element in O(log(n)).\n\nFYI, here is the exhaustive list of the data stored inside a TreeNode\n\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\n    final int hash; // inherited from Node<K,V>\n    final K key; // inherited from Node<K,V>\n    V value; // inherited from Node<K,V>\n    Node<K,V> next; // inherited from Node<K,V>\n    Entry<K,V> before, after;// inherited from LinkedHashMap.Entry<K,V>\n    TreeNode<K,V> parent;\n    TreeNode<K,V> left;\n    TreeNode<K,V> right;\n    TreeNode<K,V> prev;\n    boolean red;\nRed black trees are self-balancing binary search trees. Their inner mechanisms ensure that their length is always in log(n) despite new adds or removes of nodes. The main advantage to use those trees is in a case where many data are in the same index (bucket) of the inner table, the search in a tree will cost O(log(n)) whereas it would have cost O(n) with a linked list.\n\nAs you see, the tree takes really more space than the linked list (we’ll speak about it in the next part).\n\nBy inheritance, the inner table can contain both Node (linked list ) and TreeNode (red-black tree). Oracle decided to use both data structures with the following rules:\n– If for a given index (bucket) in the inner table there are more than 8 nodes, the linked list is transformed into a red black tree\n– If for a given index (bucket) in the inner table there are less than 6 nodes, the tree is transformed into a linked list\n\ninternal_storage_java8_hashmap\n\nThis picture shows an inner array of a JAVA 8 HashMap with both trees (at bucket 0) and linked lists (at bucket 1,2 and 3). Bucket 0 is a Tree because it has more than 8 nodes.\n\n \n\nMemory overhead\nJAVA 7\n\nThe use of a HashMap comes at a cost in terms of memory. In JAVA 7, a HashMap wraps key-value pairs in Entries. An entry has:\n\na reference to a next entry\na precomputed hash (integer)\na reference to the key\na reference to the value\nMoreover, a JAVA 7 HashMap uses an inner array of Entry. Assuming a JAVA 7 HashMap contains N elements and its inner array has a capacity CAPACITY, the extra memory cost is approximately:\n\nsizeOf(integer)* N + sizeOf(reference)* (3*N+C)\n\nWhere:\n\nthe size of an integer depends equals 4 bytes\nthe size of a reference depends on the JVM/OS/Processor but is often 4 bytes.\nWhich means that the overhead is often 16 * N + 4 * CAPACITY bytes\n\nReminder: after an auto-resizing of the Map, the  CAPACITY  of the inner array equals the next power of two after N.\n\nNote: Since JAVA 7, the HashMap class has a lazy init. That means that even if you allocate a HashMap, the inner array of entry (that costs 4 * CAPACITY bytes) won’t be allocated in memory until the first use of the put() method.\n\nJAVA 8\n\nWith the JAVA 8 implementation, it becomes a little bit complicated to get the memory usage because a Node can contain the same data as an Entry or the same data plus 6 references and a Boolean (if it’s a TreeNode).\n\nIf the all the nodes are only Nodes, the memory consumption of the JAVA 8 HashMap is the same as the JAVA 7 HashMap.\n\nIf the all the nodes are TreeNodes, the memory consumption of a JAVA 8 HashMap becomes:\n\nN * sizeOf(integer) + N * sizeOf(boolean) + sizeOf(reference)* (9*N+CAPACITY )\n\nIn most standards JVM, it’s equal to 44 * N + 4 * CAPACITY bytes\n\n \n\nPerformance issues\nSkewed HashMap vs well balanced HashMap\n\nIn the best case scenario, the get() and put() methods have a O(1) cost in time complexity. But, if you don’t take care of the hash function of the key, you might end up with very slow put() and get() calls. The good performance of the put() and get depends on the repartition of the data into the different indexes of the inner array (the buckets). If the hash function of your key is ill-designed, you’ll have a skew repartition (no matter how big the capacity of the inner array is). All the put() and get() that use the biggest linked lists of entry will be slow because they’ll need to iterate the entire lists. In the worst case scenario (if most of the data are in the same buckets), you could end up with a O(n) time complexity.\nHere is a visual example. The first picture shows a skewed HashMap and the second picture a well balanced one.\n\nskewed_java_hashmap\n\n \n\nIn the case of this skewed HashMap the get()/put() operations on the bucket 0 are costly. Getting the Entry K will cost 6 iterations\n\nwell_balanced_java_hashmapIn the case of this well balanced HashMap, getting the Entry K will cost 3 iterations. Both HashMaps store the same amount of data and have the same inner array size. The only difference is the hash (of the key) function that distributes the entries in the buckets.\n\nHere is an extreme example in JAVA where I create a hash function that puts all the data in the same bucket then I add 2 million elements.\n\npublic class Test {\n \n    public static void main(String[] args) {\n \n        class MyKey {\n            Integer i;\n            public MyKey(Integer i){\n                this.i =i;\n            }\n \n            @Override\n            public int hashCode() {\n                return 1;\n            }\n \n            @Override\n            public boolean equals(Object obj) {\n            …\n            }\n \n        }\n        Date begin = new Date();\n        Map <MyKey,String> myMap= new HashMap<>(2_500_000,1);\n        for (int i=0;i<2_000_000;i++){\n            myMap.put( new MyKey(i), \"test \"+i);\n        }\n \n        Date end = new Date();\n        System.out.println(\"Duration (ms) \"+ (end.getTime()-begin.getTime()));\n    }\n}\nOn my core i5-2500k @ 3.6Ghz it takes more than 45 minutes with java 8u40 (I stopped the process after 45 minutes).\n\nNow, If I run the same code but this time I use the following hash function\n\n    @Override\n    public int hashCode() {\n        int key = 2097152-1;\n        return key+2097152*i;\n}\nit takes 46 seconds, which is way better! This hash function has a better repartition than the previous one so the put() calls are faster.\n\nAnd If I run the same code with the following hash function that provides an even better hash repartition\n\n@Override\npublic int hashCode() {\nreturn i;\n}\nit now takes 2 seconds.\n\nI hope you realize how important the hash function is. If a ran the same test on JAVA 7, the results would have been worse for the first and second cases (since the time complexity of put is O(n) in JAVA 7 vs O(log(n)) in JAVA 8)\n\nWhen using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.\n\n \n\nResizing overhead\n\nIf you need to store a lot of data, you should create your HashMap with an initial capacity close to your expected volume.\n\nIf you don’t do that, the Map will take the default size of 16 with a factorLoad of 0.75. The 11 first put() will be very fast but the 12th (16*0.75) will recreate a new inner array (with its associated linked lists/trees) with a new capacity of 32. The 13th to 23th will be fast but the 24th (32*0.75) will recreate (again) a costly new representation that doubles the size of the inner array. The internal resizing operation will appear at the 48th, 96th,192th, … call of put(). At low volume the full recreation of the inner array is fast but at high volume it can takes seconds to minutes. By initially setting your expected size, you can avoid these costly operations.\n\nBut there is a drawback: if you set a very high array size like 2^28 whereas you’re only using 2^26 buckets in your array, you will waste a lot of memory (approximately 2^30 bytes in this case).\n\n \n\nConclusion\nFor simple use cases, you don’t need to know how HashMaps work since you won’t see the difference between a O(1) and a O(n) or O(log(n)) operation. But it’s always better to understand the underlaying mecanism of one of the most used data structures. Moreover, for a java developer position it’s a typical interview question.\n\nAt high volume it becomes important to know how it works and to understand the importance of the hash function of the key.\n\nI hope this article helped you to have a deep understanding of the HashMap implementation.","slug":"how-does-a-hashmap-work-in-java","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0d000b9t9cbdnupdqw","content":"<blockquote>\n<p>翻译自<a href=\"http://coding-geek.com/how-does-a-hashmap-work-in-java/\" target=\"_blank\" rel=\"noopener\">How does a HashMap work in JAVA - Coding Geek</a>.<br>欢迎指正错误。</p>\n</blockquote>\n<p>绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？<br>最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashMap的源码， 先是基于java 7然后java 8。<br>在这篇博文里，我将为大家展示HashMap的实现原理，在java 8中的新特性在使用中要注意的关于性能和内存的问题，以及一些常见问题。</p>\n<h6 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h6><blockquote>\n<ol>\n<li>内部存储</li>\n<li>自适应大小</li>\n<li>线程安全</li>\n<li>Key的不可变性</li>\n<li>JAVA 8中的提升</li>\n<li>内存负载<ol>\n<li>JAVA 7</li>\n<li>JAVA 8<br>7 性能问题</li>\n<li>Skewed HashMap vs well balanced HashMap</li>\n<li>自适应大小带来的开销<br>8 总结</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"Internal-storage\"><a href=\"#Internal-storage\" class=\"headerlink\" title=\"Internal storage\"></a>Internal storage</h3><p>HashMap的接口是Map&lt;K,V&gt;，这个接口的主要方法有：</p>\n<blockquote>\n<ul>\n<li>V put(K key, V value)</li>\n<li>V get(Object key)</li>\n<li>V remove(Object key)</li>\n<li>Boolean containsKey(Object key)</li>\n</ul>\n</blockquote>\n<p>HashMap真正存储数据的地方是其内部类：Entry&lt;K, V&gt;, 就是一个简单的键值对外加两个property：</p>\n<blockquote>\n<ul>\n<li>指向另一个Entry的引用，从而使HashMap可以像LinkedList一样存储多个实体</li>\n<li>key的hash值，从而避免每次使用时都要重复计算其hash值</li>\n</ul>\n</blockquote>\n<p>下面是Entry在JAVA 7中的部分代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">…</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HashMap将数据存储在多个链表中（也称为<strong>分桶</strong>或分箱），所有的链表又都保存在一个Entry数组中（数组的默认容量为<strong>16</strong>）。</p>\n<p>The following picture shows the inner storage<br>of a HashMap instance with an array of nullable entries.<br>Each Entry can link to another Entry to form a linked list.<br>下面这张图展示了一个HashMap实例的内部存储结构 - 一个支持null节点的数组。<br><img src=\"/images/internal_storage_java_hashmap.jpg\" alt=\"internal_storage\"></p>\n<p>All the keys with the same hash value are put in the same linked list (bucket). Keys with different hash values can end-up in the same bucket.</p>\n<p>When a user calls put(K key, V value) or get(Object key), the function computes the index of the bucket in which the Entry should be. Then, the function iterates through the list to look for the Entry that has the same key (using the equals() function of the key).</p>\n<p>In the case of the get(), the function returns the value associated with the entry (if the entry exists).</p>\n<p>In the case of the put(K key, V value), if the entry exists the function replaces it with the new value otherwise it creates a new entry (from the key and value in arguments) at the head of the singly linked list.</p>\n<p>This index of the bucket (linked list) is generated in 3 steps by the map:</p>\n<p>It first gets the hashcode of the key.<br>It rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array<br>It takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.<br>Here is the JAVA 7 and 8 source code that deals with the index:</p>\n<p>// the “rehash” function in JAVA 7 that takes the hashcode of the key<br>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>// the “rehash” function in JAVA 8 that directly takes the key<br>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>    }<br>// the function that returns the index from the rehashed hash<br>static int indexFor(int h, int length) {<br>    return h &amp; (length-1);<br>}<br>In order to work efficiently, the size of the inner array needs to be a power of 2, let’s see why.</p>\n<p>Imagine the array size is 17, the mask value is going to be 16 (size -1). The binary representation of 16 is 0…010000, so for any hash value H the index generated with the bitwise formula “H AND 16” is going to be either 16 or 0. This means that the array of size 17 will only be used for 2 buckets: the one at index 0 and the one at index 16, not very efficient…</p>\n<p>But, if you now take a size that is a power of 2 like 16, the bitwise index formula is “H AND 15”. The binary representation of 15 is 0…001111 so the index formula can output values from 0 to 15 and the array of size 16 is fully used. For example:</p>\n<p>if H = 952 , its binary representation is 0..01110111000, the associated index is 0…01000 = 8<br>if H = 1576 its binary representation is 0..011000101000, the associated index is  0…01000 = 8<br>if H = 12356146, its binary representation is 0..0101111001000101000110010, the associated index is 0…00010 = 2<br>if H = 59843, its binary representation is 0..01110100111000011, the associated index is 0…00011 = 3</p>\n<p>This is why the array size is a power of two. This mechanism is transparent for the developer: if he chooses a HashMap with a size of 37, the Map will automatically choose the next power of 2 after 37 (64) for the size of its inner array.</p>\n<p>Auto resizing<br>After getting the index, the function (get, put or remove) visits/iterates the associated linked list to see if there is an existing Entry for the given key. Without modification, this mechanism could lead to performance issues because the function needs to iterate through the entire list to see if the entry exists. Imagine that the size of the inner array is the default value (16) and you need to store 2 millions values. In the best case scenario, each linked list will have a size of 125 000 entries (2/16 millions). So, each get(), remove() and put() will lead to 125 000 iterations/operations. To avoid this case, the HashMap has the ability to increase its inner array in order to keep very short linked lists.</p>\n<p>When you create a HashMap, you can specify an initial size and a loadFactor with the following constructor:</p>\n<p>public HashMap(int initialCapacity, float loadFactor)<br>If you don’t specify arguments, the default initialCapacity is 16 and the default loadFactor is 0.75. The initialCapacity represents to the size of the inner array of linked lists.</p>\n<p>Each time you add a new key/value in your Map with put(…), the function checks if it needs to increase the capacity of the inner array. In order to do that, the map stores 2 data:</p>\n<p>The size of the map: it represents the number of entries in the HashMap. This value is updated each time an Entry is added or removed.<br>A threshold: it’s equal to (capacity of the inner array) * loadFactor and it is refreshed after each resize of the inner array<br>Before adding the new Entry, put(…) checks if size &gt; threshold and if it the case it recreates a new array with a doubled size. Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes. So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets (the old ones and the newly created).</p>\n<p>This aim of this resize operation is to decrease the size of the linked lists so that the time cost of put(), remove() and get() methods stays low. All entries whose keys have the same hash will stay in the same bucket after the resizing. But, 2 entries with different hash keys that were in the same bucket before might not be in the same bucket after the transformation.</p>\n<p>resizing_of_java_hashmap</p>\n<p>The picture shows a representation before and after the resizing of the inner array. Before the increase, in order to get Entry E, the map had to iterate through a list of 5 elements. After the resizing, the same get() just iterates through a linked list of 2 elements, the get() is 2 times faster after the resizing !</p>\n<p>Note: the HashMap only increases the size of the inner array, it doesn’t provide a way to decrease it.</p>\n<p>Thread Safety<br>If you already know HashMaps, you know that is not threads safe, but why? For example imagine that you have a Writer thread that puts only new data into the Map and a Reader thread that reads data from the Map, why shouldn’t it work?</p>\n<p>Because during the auto-resizing mechanism, if a thread tries to put or get an object, the map might use the old index value and won’t find the new bucket in which the entry is.</p>\n<p>The worst case scenario is when 2 threads put a data at the same time and the 2 put() calls resize the Map at the same time. Since both threads modify the linked lists at the same time, the Map might end up with an inner-loop in one of its linked lists. If you tries to get a data in the list with an inner loop, the get() will never end.</p>\n<p>The HashTable implementation is a thread safe implementation that prevents from this situation. But, since all the CRUD methods are synchronized this implementation is very slow. For example, if thread 1 calls get(key1), thread 2 calls get(key2) and thread 3 calls get(key3), only one thread at a time will be able to get its value whereas the 3 of them could access the data at the same time.</p>\n<p>A smarter implementation of a thread safe HashMap exists since JAVA 5: the ConcurrentHashMap. Only the buckets are synchronized so multiples threads can get(), remove() or put() data at the same time if it doesn’t imply accessing the same bucket or resizing the inner array. It’s better to use this implementation in a multithreaded application.</p>\n<p>Key immutability<br>Why Strings and Integers are a good implementation of keys for HashMap? Mostly because they are immutable! If you choose to create your own Key class and don’t make it immutable, you might lose data inside the HashMap.</p>\n<p>Look at the following use case:</p>\n<p>You have a key that has an inner value “1”<br>You put an object in the HashMap with this key<br>The HashMap generates a hash from the hashcode of the Key (so from “1”)<br>The Map  stores this hash in the newly created Entry<br>You modify the inner value of the key to “2”<br>The hash value of the key is modified but the HashMap doesn’t know it (because the old hash value is stored)<br>You try to get your object with your modified key<br>The map computes the new hash of your key (so from “2”) to find in which linked list (bucket) the entry is<br>Case 1: Since you modified your key, the map tries to find the entry in the wrong bucket and doesn’t find it<br> Case 2: Luckily, the modified key generates the same bucket as the old key. The map then iterates through the linked list to find the entry with the same key. But to find the key, the map first compares the hash values and then calls the equals() comparison. Since your modified key doesn’t have the same hash as the old hash value (stored in the entry), the map won’t find the entry in the linked-list.<br>Here is a concrete example in Java. I put 2 key-value pairs in my Map, I modify the first key and then try to get the 2 values. Only the second value is returned from the map, the first value is “lost” in the HashMap:</p>\n<p>public class MutableKeyTest {</p>\n<pre><code>public static void main(String[] args) {\n\n    class MyKey {\n        Integer i;\n\n        public void setI(Integer i) {\n            this.i = i;\n        }\n\n        public MyKey(Integer i) {\n            this.i = i;\n        }\n\n        @Override\n        public int hashCode() {\n            return i;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof MyKey) {\n                return i.equals(((MyKey) obj).i);\n            } else\n                return false;\n        }\n\n    }\n\n    Map&lt;MyKey, String&gt; myMap = new HashMap&lt;&gt;();\n    MyKey key1 = new MyKey(1);\n    MyKey key2 = new MyKey(2);\n\n    myMap.put(key1, &quot;test &quot; + 1);\n    myMap.put(key2, &quot;test &quot; + 2);\n\n    // modifying key1\n    key1.setI(3);\n\n    String test1 = myMap.get(key1);\n    String test2 = myMap.get(key2);\n\n    System.out.println(&quot;test1= &quot; + test1 + &quot; test2=&quot; + test2);\n\n}\n</code></pre><p>}<br>The output is: “test1= null test2=test 2”. As expected, the Map wasn’t able to retrieve the string 1 with the modified key 1.</p>\n<p>JAVA 8 improvements<br>The inner representation of the HashMap has changed a lot in JAVA 8. Indeed, the implementation in JAVA 7 takes 1k lines of code whereas the implementation in JAVA 8 takes 2k lines. Most of what I’ve said previously is true except the linked lists of entries. In JAVA8, you still have an array but it now stores Nodes that contains the exact same information as Entries and therefore are also linked lists:</p>\n<p>Here is a part of the Node implementation in JAVA 8:</p>\n<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>     final int hash;<br>     final K key;<br>     V value;<br>     Node&lt;K,V&gt; next;<br>So what’s the big difference with JAVA 7? Well, Nodes can be extended to TreeNodes. A TreeNode is a red-black tree structure that stores really more information so that it can add, delete or get an element in O(log(n)).</p>\n<p>FYI, here is the exhaustive list of the data stored inside a TreeNode</p>\n<p>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {<br>    final int hash; // inherited from Node&lt;K,V&gt;<br>    final K key; // inherited from Node&lt;K,V&gt;<br>    V value; // inherited from Node&lt;K,V&gt;<br>    Node&lt;K,V&gt; next; // inherited from Node&lt;K,V&gt;<br>    Entry&lt;K,V&gt; before, after;// inherited from LinkedHashMap.Entry&lt;K,V&gt;<br>    TreeNode&lt;K,V&gt; parent;<br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;<br>    boolean red;<br>Red black trees are self-balancing binary search trees. Their inner mechanisms ensure that their length is always in log(n) despite new adds or removes of nodes. The main advantage to use those trees is in a case where many data are in the same index (bucket) of the inner table, the search in a tree will cost O(log(n)) whereas it would have cost O(n) with a linked list.</p>\n<p>As you see, the tree takes really more space than the linked list (we’ll speak about it in the next part).</p>\n<p>By inheritance, the inner table can contain both Node (linked list ) and TreeNode (red-black tree). Oracle decided to use both data structures with the following rules:<br>– If for a given index (bucket) in the inner table there are more than 8 nodes, the linked list is transformed into a red black tree<br>– If for a given index (bucket) in the inner table there are less than 6 nodes, the tree is transformed into a linked list</p>\n<p>internal_storage_java8_hashmap</p>\n<p>This picture shows an inner array of a JAVA 8 HashMap with both trees (at bucket 0) and linked lists (at bucket 1,2 and 3). Bucket 0 is a Tree because it has more than 8 nodes.</p>\n<p>Memory overhead<br>JAVA 7</p>\n<p>The use of a HashMap comes at a cost in terms of memory. In JAVA 7, a HashMap wraps key-value pairs in Entries. An entry has:</p>\n<p>a reference to a next entry<br>a precomputed hash (integer)<br>a reference to the key<br>a reference to the value<br>Moreover, a JAVA 7 HashMap uses an inner array of Entry. Assuming a JAVA 7 HashMap contains N elements and its inner array has a capacity CAPACITY, the extra memory cost is approximately:</p>\n<p>sizeOf(integer)<em> N + sizeOf(reference)</em> (3*N+C)</p>\n<p>Where:</p>\n<p>the size of an integer depends equals 4 bytes<br>the size of a reference depends on the JVM/OS/Processor but is often 4 bytes.<br>Which means that the overhead is often 16 <em> N + 4 </em> CAPACITY bytes</p>\n<p>Reminder: after an auto-resizing of the Map, the  CAPACITY  of the inner array equals the next power of two after N.</p>\n<p>Note: Since JAVA 7, the HashMap class has a lazy init. That means that even if you allocate a HashMap, the inner array of entry (that costs 4 * CAPACITY bytes) won’t be allocated in memory until the first use of the put() method.</p>\n<p>JAVA 8</p>\n<p>With the JAVA 8 implementation, it becomes a little bit complicated to get the memory usage because a Node can contain the same data as an Entry or the same data plus 6 references and a Boolean (if it’s a TreeNode).</p>\n<p>If the all the nodes are only Nodes, the memory consumption of the JAVA 8 HashMap is the same as the JAVA 7 HashMap.</p>\n<p>If the all the nodes are TreeNodes, the memory consumption of a JAVA 8 HashMap becomes:</p>\n<p>N <em> sizeOf(integer) + N </em> sizeOf(boolean) + sizeOf(reference)<em> (9</em>N+CAPACITY )</p>\n<p>In most standards JVM, it’s equal to 44 <em> N + 4 </em> CAPACITY bytes</p>\n<p>Performance issues<br>Skewed HashMap vs well balanced HashMap</p>\n<p>In the best case scenario, the get() and put() methods have a O(1) cost in time complexity. But, if you don’t take care of the hash function of the key, you might end up with very slow put() and get() calls. The good performance of the put() and get depends on the repartition of the data into the different indexes of the inner array (the buckets). If the hash function of your key is ill-designed, you’ll have a skew repartition (no matter how big the capacity of the inner array is). All the put() and get() that use the biggest linked lists of entry will be slow because they’ll need to iterate the entire lists. In the worst case scenario (if most of the data are in the same buckets), you could end up with a O(n) time complexity.<br>Here is a visual example. The first picture shows a skewed HashMap and the second picture a well balanced one.</p>\n<p>skewed_java_hashmap</p>\n<p>In the case of this skewed HashMap the get()/put() operations on the bucket 0 are costly. Getting the Entry K will cost 6 iterations</p>\n<p>well_balanced_java_hashmapIn the case of this well balanced HashMap, getting the Entry K will cost 3 iterations. Both HashMaps store the same amount of data and have the same inner array size. The only difference is the hash (of the key) function that distributes the entries in the buckets.</p>\n<p>Here is an extreme example in JAVA where I create a hash function that puts all the data in the same bucket then I add 2 million elements.</p>\n<p>public class Test {</p>\n<pre><code>public static void main(String[] args) {\n\n    class MyKey {\n        Integer i;\n        public MyKey(Integer i){\n            this.i =i;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n        …\n        }\n\n    }\n    Date begin = new Date();\n    Map &lt;MyKey,String&gt; myMap= new HashMap&lt;&gt;(2_500_000,1);\n    for (int i=0;i&lt;2_000_000;i++){\n        myMap.put( new MyKey(i), &quot;test &quot;+i);\n    }\n\n    Date end = new Date();\n    System.out.println(&quot;Duration (ms) &quot;+ (end.getTime()-begin.getTime()));\n}\n</code></pre><p>}<br>On my core i5-2500k @ 3.6Ghz it takes more than 45 minutes with java 8u40 (I stopped the process after 45 minutes).</p>\n<p>Now, If I run the same code but this time I use the following hash function</p>\n<pre><code>@Override\npublic int hashCode() {\n    int key = 2097152-1;\n    return key+2097152*i;\n</code></pre><p>}<br>it takes 46 seconds, which is way better! This hash function has a better repartition than the previous one so the put() calls are faster.</p>\n<p>And If I run the same code with the following hash function that provides an even better hash repartition</p>\n<p>@Override<br>public int hashCode() {<br>return i;<br>}<br>it now takes 2 seconds.</p>\n<p>I hope you realize how important the hash function is. If a ran the same test on JAVA 7, the results would have been worse for the first and second cases (since the time complexity of put is O(n) in JAVA 7 vs O(log(n)) in JAVA 8)</p>\n<p>When using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.</p>\n<p>Resizing overhead</p>\n<p>If you need to store a lot of data, you should create your HashMap with an initial capacity close to your expected volume.</p>\n<p>If you don’t do that, the Map will take the default size of 16 with a factorLoad of 0.75. The 11 first put() will be very fast but the 12th (16<em>0.75) will recreate a new inner array (with its associated linked lists/trees) with a new capacity of 32. The 13th to 23th will be fast but the 24th (32</em>0.75) will recreate (again) a costly new representation that doubles the size of the inner array. The internal resizing operation will appear at the 48th, 96th,192th, … call of put(). At low volume the full recreation of the inner array is fast but at high volume it can takes seconds to minutes. By initially setting your expected size, you can avoid these costly operations.</p>\n<p>But there is a drawback: if you set a very high array size like 2^28 whereas you’re only using 2^26 buckets in your array, you will waste a lot of memory (approximately 2^30 bytes in this case).</p>\n<p>Conclusion<br>For simple use cases, you don’t need to know how HashMaps work since you won’t see the difference between a O(1) and a O(n) or O(log(n)) operation. But it’s always better to understand the underlaying mecanism of one of the most used data structures. Moreover, for a java developer position it’s a typical interview question.</p>\n<p>At high volume it becomes important to know how it works and to understand the importance of the hash function of the key.</p>\n<p>I hope this article helped you to have a deep understanding of the HashMap implementation.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>翻译自<a href=\"http://coding-geek.com/how-does-a-hashmap-work-in-java/\" target=\"_blank\" rel=\"noopener\">How does a HashMap work in JAVA - Coding Geek</a>.<br>欢迎指正错误。</p>\n</blockquote>\n<p>绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？<br>最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashMap的源码， 先是基于java 7然后java 8。<br>在这篇博文里，我将为大家展示HashMap的实现原理，在java 8中的新特性在使用中要注意的关于性能和内存的问题，以及一些常见问题。</p>\n<h6 id=\"Contents\"><a href=\"#Contents\" class=\"headerlink\" title=\"Contents\"></a>Contents</h6><blockquote>\n<ol>\n<li>内部存储</li>\n<li>自适应大小</li>\n<li>线程安全</li>\n<li>Key的不可变性</li>\n<li>JAVA 8中的提升</li>\n<li>内存负载<ol>\n<li>JAVA 7</li>\n<li>JAVA 8<br>7 性能问题</li>\n<li>Skewed HashMap vs well balanced HashMap</li>\n<li>自适应大小带来的开销<br>8 总结</li>\n</ol>\n</li>\n</ol>\n</blockquote>","more":"<h3 id=\"Internal-storage\"><a href=\"#Internal-storage\" class=\"headerlink\" title=\"Internal storage\"></a>Internal storage</h3><p>HashMap的接口是Map&lt;K,V&gt;，这个接口的主要方法有：</p>\n<blockquote>\n<ul>\n<li>V put(K key, V value)</li>\n<li>V get(Object key)</li>\n<li>V remove(Object key)</li>\n<li>Boolean containsKey(Object key)</li>\n</ul>\n</blockquote>\n<p>HashMap真正存储数据的地方是其内部类：Entry&lt;K, V&gt;, 就是一个简单的键值对外加两个property：</p>\n<blockquote>\n<ul>\n<li>指向另一个Entry的引用，从而使HashMap可以像LinkedList一样存储多个实体</li>\n<li>key的hash值，从而避免每次使用时都要重复计算其hash值</li>\n</ul>\n</blockquote>\n<p>下面是Entry在JAVA 7中的部分代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">        V value;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">…</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>HashMap将数据存储在多个链表中（也称为<strong>分桶</strong>或分箱），所有的链表又都保存在一个Entry数组中（数组的默认容量为<strong>16</strong>）。</p>\n<p>The following picture shows the inner storage<br>of a HashMap instance with an array of nullable entries.<br>Each Entry can link to another Entry to form a linked list.<br>下面这张图展示了一个HashMap实例的内部存储结构 - 一个支持null节点的数组。<br><img src=\"/images/internal_storage_java_hashmap.jpg\" alt=\"internal_storage\"></p>\n<p>All the keys with the same hash value are put in the same linked list (bucket). Keys with different hash values can end-up in the same bucket.</p>\n<p>When a user calls put(K key, V value) or get(Object key), the function computes the index of the bucket in which the Entry should be. Then, the function iterates through the list to look for the Entry that has the same key (using the equals() function of the key).</p>\n<p>In the case of the get(), the function returns the value associated with the entry (if the entry exists).</p>\n<p>In the case of the put(K key, V value), if the entry exists the function replaces it with the new value otherwise it creates a new entry (from the key and value in arguments) at the head of the singly linked list.</p>\n<p>This index of the bucket (linked list) is generated in 3 steps by the map:</p>\n<p>It first gets the hashcode of the key.<br>It rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array<br>It takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.<br>Here is the JAVA 7 and 8 source code that deals with the index:</p>\n<p>// the “rehash” function in JAVA 7 that takes the hashcode of the key<br>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>// the “rehash” function in JAVA 8 that directly takes the key<br>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>    }<br>// the function that returns the index from the rehashed hash<br>static int indexFor(int h, int length) {<br>    return h &amp; (length-1);<br>}<br>In order to work efficiently, the size of the inner array needs to be a power of 2, let’s see why.</p>\n<p>Imagine the array size is 17, the mask value is going to be 16 (size -1). The binary representation of 16 is 0…010000, so for any hash value H the index generated with the bitwise formula “H AND 16” is going to be either 16 or 0. This means that the array of size 17 will only be used for 2 buckets: the one at index 0 and the one at index 16, not very efficient…</p>\n<p>But, if you now take a size that is a power of 2 like 16, the bitwise index formula is “H AND 15”. The binary representation of 15 is 0…001111 so the index formula can output values from 0 to 15 and the array of size 16 is fully used. For example:</p>\n<p>if H = 952 , its binary representation is 0..01110111000, the associated index is 0…01000 = 8<br>if H = 1576 its binary representation is 0..011000101000, the associated index is  0…01000 = 8<br>if H = 12356146, its binary representation is 0..0101111001000101000110010, the associated index is 0…00010 = 2<br>if H = 59843, its binary representation is 0..01110100111000011, the associated index is 0…00011 = 3</p>\n<p>This is why the array size is a power of two. This mechanism is transparent for the developer: if he chooses a HashMap with a size of 37, the Map will automatically choose the next power of 2 after 37 (64) for the size of its inner array.</p>\n<p>Auto resizing<br>After getting the index, the function (get, put or remove) visits/iterates the associated linked list to see if there is an existing Entry for the given key. Without modification, this mechanism could lead to performance issues because the function needs to iterate through the entire list to see if the entry exists. Imagine that the size of the inner array is the default value (16) and you need to store 2 millions values. In the best case scenario, each linked list will have a size of 125 000 entries (2/16 millions). So, each get(), remove() and put() will lead to 125 000 iterations/operations. To avoid this case, the HashMap has the ability to increase its inner array in order to keep very short linked lists.</p>\n<p>When you create a HashMap, you can specify an initial size and a loadFactor with the following constructor:</p>\n<p>public HashMap(int initialCapacity, float loadFactor)<br>If you don’t specify arguments, the default initialCapacity is 16 and the default loadFactor is 0.75. The initialCapacity represents to the size of the inner array of linked lists.</p>\n<p>Each time you add a new key/value in your Map with put(…), the function checks if it needs to increase the capacity of the inner array. In order to do that, the map stores 2 data:</p>\n<p>The size of the map: it represents the number of entries in the HashMap. This value is updated each time an Entry is added or removed.<br>A threshold: it’s equal to (capacity of the inner array) * loadFactor and it is refreshed after each resize of the inner array<br>Before adding the new Entry, put(…) checks if size &gt; threshold and if it the case it recreates a new array with a doubled size. Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes. So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets (the old ones and the newly created).</p>\n<p>This aim of this resize operation is to decrease the size of the linked lists so that the time cost of put(), remove() and get() methods stays low. All entries whose keys have the same hash will stay in the same bucket after the resizing. But, 2 entries with different hash keys that were in the same bucket before might not be in the same bucket after the transformation.</p>\n<p>resizing_of_java_hashmap</p>\n<p>The picture shows a representation before and after the resizing of the inner array. Before the increase, in order to get Entry E, the map had to iterate through a list of 5 elements. After the resizing, the same get() just iterates through a linked list of 2 elements, the get() is 2 times faster after the resizing !</p>\n<p>Note: the HashMap only increases the size of the inner array, it doesn’t provide a way to decrease it.</p>\n<p>Thread Safety<br>If you already know HashMaps, you know that is not threads safe, but why? For example imagine that you have a Writer thread that puts only new data into the Map and a Reader thread that reads data from the Map, why shouldn’t it work?</p>\n<p>Because during the auto-resizing mechanism, if a thread tries to put or get an object, the map might use the old index value and won’t find the new bucket in which the entry is.</p>\n<p>The worst case scenario is when 2 threads put a data at the same time and the 2 put() calls resize the Map at the same time. Since both threads modify the linked lists at the same time, the Map might end up with an inner-loop in one of its linked lists. If you tries to get a data in the list with an inner loop, the get() will never end.</p>\n<p>The HashTable implementation is a thread safe implementation that prevents from this situation. But, since all the CRUD methods are synchronized this implementation is very slow. For example, if thread 1 calls get(key1), thread 2 calls get(key2) and thread 3 calls get(key3), only one thread at a time will be able to get its value whereas the 3 of them could access the data at the same time.</p>\n<p>A smarter implementation of a thread safe HashMap exists since JAVA 5: the ConcurrentHashMap. Only the buckets are synchronized so multiples threads can get(), remove() or put() data at the same time if it doesn’t imply accessing the same bucket or resizing the inner array. It’s better to use this implementation in a multithreaded application.</p>\n<p>Key immutability<br>Why Strings and Integers are a good implementation of keys for HashMap? Mostly because they are immutable! If you choose to create your own Key class and don’t make it immutable, you might lose data inside the HashMap.</p>\n<p>Look at the following use case:</p>\n<p>You have a key that has an inner value “1”<br>You put an object in the HashMap with this key<br>The HashMap generates a hash from the hashcode of the Key (so from “1”)<br>The Map  stores this hash in the newly created Entry<br>You modify the inner value of the key to “2”<br>The hash value of the key is modified but the HashMap doesn’t know it (because the old hash value is stored)<br>You try to get your object with your modified key<br>The map computes the new hash of your key (so from “2”) to find in which linked list (bucket) the entry is<br>Case 1: Since you modified your key, the map tries to find the entry in the wrong bucket and doesn’t find it<br> Case 2: Luckily, the modified key generates the same bucket as the old key. The map then iterates through the linked list to find the entry with the same key. But to find the key, the map first compares the hash values and then calls the equals() comparison. Since your modified key doesn’t have the same hash as the old hash value (stored in the entry), the map won’t find the entry in the linked-list.<br>Here is a concrete example in Java. I put 2 key-value pairs in my Map, I modify the first key and then try to get the 2 values. Only the second value is returned from the map, the first value is “lost” in the HashMap:</p>\n<p>public class MutableKeyTest {</p>\n<pre><code>public static void main(String[] args) {\n\n    class MyKey {\n        Integer i;\n\n        public void setI(Integer i) {\n            this.i = i;\n        }\n\n        public MyKey(Integer i) {\n            this.i = i;\n        }\n\n        @Override\n        public int hashCode() {\n            return i;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof MyKey) {\n                return i.equals(((MyKey) obj).i);\n            } else\n                return false;\n        }\n\n    }\n\n    Map&lt;MyKey, String&gt; myMap = new HashMap&lt;&gt;();\n    MyKey key1 = new MyKey(1);\n    MyKey key2 = new MyKey(2);\n\n    myMap.put(key1, &quot;test &quot; + 1);\n    myMap.put(key2, &quot;test &quot; + 2);\n\n    // modifying key1\n    key1.setI(3);\n\n    String test1 = myMap.get(key1);\n    String test2 = myMap.get(key2);\n\n    System.out.println(&quot;test1= &quot; + test1 + &quot; test2=&quot; + test2);\n\n}\n</code></pre><p>}<br>The output is: “test1= null test2=test 2”. As expected, the Map wasn’t able to retrieve the string 1 with the modified key 1.</p>\n<p>JAVA 8 improvements<br>The inner representation of the HashMap has changed a lot in JAVA 8. Indeed, the implementation in JAVA 7 takes 1k lines of code whereas the implementation in JAVA 8 takes 2k lines. Most of what I’ve said previously is true except the linked lists of entries. In JAVA8, you still have an array but it now stores Nodes that contains the exact same information as Entries and therefore are also linked lists:</p>\n<p>Here is a part of the Node implementation in JAVA 8:</p>\n<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>     final int hash;<br>     final K key;<br>     V value;<br>     Node&lt;K,V&gt; next;<br>So what’s the big difference with JAVA 7? Well, Nodes can be extended to TreeNodes. A TreeNode is a red-black tree structure that stores really more information so that it can add, delete or get an element in O(log(n)).</p>\n<p>FYI, here is the exhaustive list of the data stored inside a TreeNode</p>\n<p>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {<br>    final int hash; // inherited from Node&lt;K,V&gt;<br>    final K key; // inherited from Node&lt;K,V&gt;<br>    V value; // inherited from Node&lt;K,V&gt;<br>    Node&lt;K,V&gt; next; // inherited from Node&lt;K,V&gt;<br>    Entry&lt;K,V&gt; before, after;// inherited from LinkedHashMap.Entry&lt;K,V&gt;<br>    TreeNode&lt;K,V&gt; parent;<br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;<br>    boolean red;<br>Red black trees are self-balancing binary search trees. Their inner mechanisms ensure that their length is always in log(n) despite new adds or removes of nodes. The main advantage to use those trees is in a case where many data are in the same index (bucket) of the inner table, the search in a tree will cost O(log(n)) whereas it would have cost O(n) with a linked list.</p>\n<p>As you see, the tree takes really more space than the linked list (we’ll speak about it in the next part).</p>\n<p>By inheritance, the inner table can contain both Node (linked list ) and TreeNode (red-black tree). Oracle decided to use both data structures with the following rules:<br>– If for a given index (bucket) in the inner table there are more than 8 nodes, the linked list is transformed into a red black tree<br>– If for a given index (bucket) in the inner table there are less than 6 nodes, the tree is transformed into a linked list</p>\n<p>internal_storage_java8_hashmap</p>\n<p>This picture shows an inner array of a JAVA 8 HashMap with both trees (at bucket 0) and linked lists (at bucket 1,2 and 3). Bucket 0 is a Tree because it has more than 8 nodes.</p>\n<p>Memory overhead<br>JAVA 7</p>\n<p>The use of a HashMap comes at a cost in terms of memory. In JAVA 7, a HashMap wraps key-value pairs in Entries. An entry has:</p>\n<p>a reference to a next entry<br>a precomputed hash (integer)<br>a reference to the key<br>a reference to the value<br>Moreover, a JAVA 7 HashMap uses an inner array of Entry. Assuming a JAVA 7 HashMap contains N elements and its inner array has a capacity CAPACITY, the extra memory cost is approximately:</p>\n<p>sizeOf(integer)<em> N + sizeOf(reference)</em> (3*N+C)</p>\n<p>Where:</p>\n<p>the size of an integer depends equals 4 bytes<br>the size of a reference depends on the JVM/OS/Processor but is often 4 bytes.<br>Which means that the overhead is often 16 <em> N + 4 </em> CAPACITY bytes</p>\n<p>Reminder: after an auto-resizing of the Map, the  CAPACITY  of the inner array equals the next power of two after N.</p>\n<p>Note: Since JAVA 7, the HashMap class has a lazy init. That means that even if you allocate a HashMap, the inner array of entry (that costs 4 * CAPACITY bytes) won’t be allocated in memory until the first use of the put() method.</p>\n<p>JAVA 8</p>\n<p>With the JAVA 8 implementation, it becomes a little bit complicated to get the memory usage because a Node can contain the same data as an Entry or the same data plus 6 references and a Boolean (if it’s a TreeNode).</p>\n<p>If the all the nodes are only Nodes, the memory consumption of the JAVA 8 HashMap is the same as the JAVA 7 HashMap.</p>\n<p>If the all the nodes are TreeNodes, the memory consumption of a JAVA 8 HashMap becomes:</p>\n<p>N <em> sizeOf(integer) + N </em> sizeOf(boolean) + sizeOf(reference)<em> (9</em>N+CAPACITY )</p>\n<p>In most standards JVM, it’s equal to 44 <em> N + 4 </em> CAPACITY bytes</p>\n<p>Performance issues<br>Skewed HashMap vs well balanced HashMap</p>\n<p>In the best case scenario, the get() and put() methods have a O(1) cost in time complexity. But, if you don’t take care of the hash function of the key, you might end up with very slow put() and get() calls. The good performance of the put() and get depends on the repartition of the data into the different indexes of the inner array (the buckets). If the hash function of your key is ill-designed, you’ll have a skew repartition (no matter how big the capacity of the inner array is). All the put() and get() that use the biggest linked lists of entry will be slow because they’ll need to iterate the entire lists. In the worst case scenario (if most of the data are in the same buckets), you could end up with a O(n) time complexity.<br>Here is a visual example. The first picture shows a skewed HashMap and the second picture a well balanced one.</p>\n<p>skewed_java_hashmap</p>\n<p>In the case of this skewed HashMap the get()/put() operations on the bucket 0 are costly. Getting the Entry K will cost 6 iterations</p>\n<p>well_balanced_java_hashmapIn the case of this well balanced HashMap, getting the Entry K will cost 3 iterations. Both HashMaps store the same amount of data and have the same inner array size. The only difference is the hash (of the key) function that distributes the entries in the buckets.</p>\n<p>Here is an extreme example in JAVA where I create a hash function that puts all the data in the same bucket then I add 2 million elements.</p>\n<p>public class Test {</p>\n<pre><code>public static void main(String[] args) {\n\n    class MyKey {\n        Integer i;\n        public MyKey(Integer i){\n            this.i =i;\n        }\n\n        @Override\n        public int hashCode() {\n            return 1;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n        …\n        }\n\n    }\n    Date begin = new Date();\n    Map &lt;MyKey,String&gt; myMap= new HashMap&lt;&gt;(2_500_000,1);\n    for (int i=0;i&lt;2_000_000;i++){\n        myMap.put( new MyKey(i), &quot;test &quot;+i);\n    }\n\n    Date end = new Date();\n    System.out.println(&quot;Duration (ms) &quot;+ (end.getTime()-begin.getTime()));\n}\n</code></pre><p>}<br>On my core i5-2500k @ 3.6Ghz it takes more than 45 minutes with java 8u40 (I stopped the process after 45 minutes).</p>\n<p>Now, If I run the same code but this time I use the following hash function</p>\n<pre><code>@Override\npublic int hashCode() {\n    int key = 2097152-1;\n    return key+2097152*i;\n</code></pre><p>}<br>it takes 46 seconds, which is way better! This hash function has a better repartition than the previous one so the put() calls are faster.</p>\n<p>And If I run the same code with the following hash function that provides an even better hash repartition</p>\n<p>@Override<br>public int hashCode() {<br>return i;<br>}<br>it now takes 2 seconds.</p>\n<p>I hope you realize how important the hash function is. If a ran the same test on JAVA 7, the results would have been worse for the first and second cases (since the time complexity of put is O(n) in JAVA 7 vs O(log(n)) in JAVA 8)</p>\n<p>When using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.</p>\n<p>Resizing overhead</p>\n<p>If you need to store a lot of data, you should create your HashMap with an initial capacity close to your expected volume.</p>\n<p>If you don’t do that, the Map will take the default size of 16 with a factorLoad of 0.75. The 11 first put() will be very fast but the 12th (16<em>0.75) will recreate a new inner array (with its associated linked lists/trees) with a new capacity of 32. The 13th to 23th will be fast but the 24th (32</em>0.75) will recreate (again) a costly new representation that doubles the size of the inner array. The internal resizing operation will appear at the 48th, 96th,192th, … call of put(). At low volume the full recreation of the inner array is fast but at high volume it can takes seconds to minutes. By initially setting your expected size, you can avoid these costly operations.</p>\n<p>But there is a drawback: if you set a very high array size like 2^28 whereas you’re only using 2^26 buckets in your array, you will waste a lot of memory (approximately 2^30 bytes in this case).</p>\n<p>Conclusion<br>For simple use cases, you don’t need to know how HashMaps work since you won’t see the difference between a O(1) and a O(n) or O(log(n)) operation. But it’s always better to understand the underlaying mecanism of one of the most used data structures. Moreover, for a java developer position it’s a typical interview question.</p>\n<p>At high volume it becomes important to know how it works and to understand the importance of the hash function of the key.</p>\n<p>I hope this article helped you to have a deep understanding of the HashMap implementation.</p>"},{"title":"RocketMQ二安装与简单实用","date":"2018-03-13T18:21:26.000Z","_content":"\n### 目录\n#### 部署\n >* 1 Master\n >* 2 Master\n >* 2 Master - 2 Salve async\n >* 2 Master - 2 Salve sync            \n#### 控制台安装\n#### 发送消息的默认约定\n#### 消费消息的默认约定\n#### 并行消息(多线程多Queue)\n#### 有序消息(单线程单一ueue)\n#### 延迟消息(单线程单一ueue)\n<!--more-->\n----\n### 部署\n    下载并解压[rocketmq](http://mirrors.tuna.tsinghua.edu.cn/apache/incubator/rocketmq/4.0.0-incubating/rocketmq-all-4.0.0-incubating-bin-release.zip )\n#### 1 Master\n* 启动nameServer\n    ```\n    nohup sh bin/mqnamesrv &\n    ```\n* 启动broker\n    ```\n    nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &\n    ```\n* shutdown\n    ```\n    bin/mqshutdown broker\n    bin/mqshutdown namesrv\n    ```\n#### 2 Master\n    TODO\n    \n#### 2 Master - 2 Salve async\n    TODO\n    \n#### 2 Master - 2 Salve sync\n\n    TODO\n### 控制台安装\n>控制台使用apache/incubator-rocketmq-externals下的rocketmq-console\n* clone：\n    ```\n    https://github.com/apache/incubator-rocketmq-externals.git\n    ```\n* 打包\n    ```\n    mvn clean package -Dmaven.test.skip=true\n    ```\n* 启动\n    ```\n    java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=localhost:9876\n    ```\n* 访问控制台：http://localhost:12581\n\n### 发送消息的默认约定：\n* 一个JVM一个MqMessageSender实例，后续视情况是否改为prototype\n* 默认发送方式为同步 - sendMsg(String, String, String, String)\n* client没有必要retry\n    > rocketMQ已经有retry, MqMessageSender里也会做必要的失败记录和服务不可用时的retry\n    * rocketMQ的retry\n        ```\n        defaultSendingTimeout = 3000 mills\n        retryTimesWhenSendFailed = 2\n        ```\n    * 如果发送失败，确保消息不丢失\n    * MqMessageSender会保存消息到DB，同时抛出unCheckedException\n        * （TODO）服务可用后，可以从DB中重新发送\n        * 应用程序接收到Exception后，做必要处理\n* producerGroup\n    * 作用：\n    >* 标识一类 Producer\n    >* 可以通过运维工具查询这个发送消息应用下有多个 Producer 实例\n    >* 发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态。\n    \n    * one producerGroup per application as default\n    >* 一个 Producer Group 下包含多个 Producer 实例，可以是多台机器， 也可以是一台机器的多个进程，或者一个进程的多个 Producer 对象。\n    >* 一个 Producer Group 可以发送多个 Topic 消息.\n\n### 消费消息的默认约定：\n    TODO\n### 并行消息(多线程多Queue)\n\n### 有序消息(单线程单一ueue)\n\n### 延迟消息(单线程单一ueue)","source":"_posts/rocketMQ-2-installation-and-simple-usages.md","raw":"---\ntitle: RocketMQ二安装与简单实用\ndate: 2018-03-14 02:21:26\ncategories: \n- MQ\n- RocketMQ\ntags:\n- MQ\n- RocketMQ\n---\n\n### 目录\n#### 部署\n >* 1 Master\n >* 2 Master\n >* 2 Master - 2 Salve async\n >* 2 Master - 2 Salve sync            \n#### 控制台安装\n#### 发送消息的默认约定\n#### 消费消息的默认约定\n#### 并行消息(多线程多Queue)\n#### 有序消息(单线程单一ueue)\n#### 延迟消息(单线程单一ueue)\n<!--more-->\n----\n### 部署\n    下载并解压[rocketmq](http://mirrors.tuna.tsinghua.edu.cn/apache/incubator/rocketmq/4.0.0-incubating/rocketmq-all-4.0.0-incubating-bin-release.zip )\n#### 1 Master\n* 启动nameServer\n    ```\n    nohup sh bin/mqnamesrv &\n    ```\n* 启动broker\n    ```\n    nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &\n    ```\n* shutdown\n    ```\n    bin/mqshutdown broker\n    bin/mqshutdown namesrv\n    ```\n#### 2 Master\n    TODO\n    \n#### 2 Master - 2 Salve async\n    TODO\n    \n#### 2 Master - 2 Salve sync\n\n    TODO\n### 控制台安装\n>控制台使用apache/incubator-rocketmq-externals下的rocketmq-console\n* clone：\n    ```\n    https://github.com/apache/incubator-rocketmq-externals.git\n    ```\n* 打包\n    ```\n    mvn clean package -Dmaven.test.skip=true\n    ```\n* 启动\n    ```\n    java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=localhost:9876\n    ```\n* 访问控制台：http://localhost:12581\n\n### 发送消息的默认约定：\n* 一个JVM一个MqMessageSender实例，后续视情况是否改为prototype\n* 默认发送方式为同步 - sendMsg(String, String, String, String)\n* client没有必要retry\n    > rocketMQ已经有retry, MqMessageSender里也会做必要的失败记录和服务不可用时的retry\n    * rocketMQ的retry\n        ```\n        defaultSendingTimeout = 3000 mills\n        retryTimesWhenSendFailed = 2\n        ```\n    * 如果发送失败，确保消息不丢失\n    * MqMessageSender会保存消息到DB，同时抛出unCheckedException\n        * （TODO）服务可用后，可以从DB中重新发送\n        * 应用程序接收到Exception后，做必要处理\n* producerGroup\n    * 作用：\n    >* 标识一类 Producer\n    >* 可以通过运维工具查询这个发送消息应用下有多个 Producer 实例\n    >* 发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态。\n    \n    * one producerGroup per application as default\n    >* 一个 Producer Group 下包含多个 Producer 实例，可以是多台机器， 也可以是一台机器的多个进程，或者一个进程的多个 Producer 对象。\n    >* 一个 Producer Group 可以发送多个 Topic 消息.\n\n### 消费消息的默认约定：\n    TODO\n### 并行消息(多线程多Queue)\n\n### 有序消息(单线程单一ueue)\n\n### 延迟消息(单线程单一ueue)","slug":"rocketMQ-2-installation-and-simple-usages","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0e000c9t9cwn50t4h5","content":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><h4 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h4><blockquote>\n<ul>\n<li>1 Master</li>\n<li>2 Master</li>\n<li>2 Master - 2 Salve async</li>\n<li>2 Master - 2 Salve sync            </li>\n</ul>\n</blockquote>\n<h4 id=\"控制台安装\"><a href=\"#控制台安装\" class=\"headerlink\" title=\"控制台安装\"></a>控制台安装</h4><h4 id=\"发送消息的默认约定\"><a href=\"#发送消息的默认约定\" class=\"headerlink\" title=\"发送消息的默认约定\"></a>发送消息的默认约定</h4><h4 id=\"消费消息的默认约定\"><a href=\"#消费消息的默认约定\" class=\"headerlink\" title=\"消费消息的默认约定\"></a>消费消息的默认约定</h4><h4 id=\"并行消息-多线程多Queue\"><a href=\"#并行消息-多线程多Queue\" class=\"headerlink\" title=\"并行消息(多线程多Queue)\"></a>并行消息(多线程多Queue)</h4><h4 id=\"有序消息-单线程单一ueue\"><a href=\"#有序消息-单线程单一ueue\" class=\"headerlink\" title=\"有序消息(单线程单一ueue)\"></a>有序消息(单线程单一ueue)</h4><h4 id=\"延迟消息-单线程单一ueue\"><a href=\"#延迟消息-单线程单一ueue\" class=\"headerlink\" title=\"延迟消息(单线程单一ueue)\"></a>延迟消息(单线程单一ueue)</h4><a id=\"more\"></a>\n<hr>\n<h3 id=\"部署-1\"><a href=\"#部署-1\" class=\"headerlink\" title=\"部署\"></a>部署</h3><pre><code>下载并解压[rocketmq](http://mirrors.tuna.tsinghua.edu.cn/apache/incubator/rocketmq/4.0.0-incubating/rocketmq-all-4.0.0-incubating-bin-release.zip )\n</code></pre><h4 id=\"1-Master\"><a href=\"#1-Master\" class=\"headerlink\" title=\"1 Master\"></a>1 Master</h4><ul>\n<li><p>启动nameServer</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动broker</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shutdown</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/mqshutdown broker</span><br><span class=\"line\">bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-Master\"><a href=\"#2-Master\" class=\"headerlink\" title=\"2 Master\"></a>2 Master</h4><pre><code>TODO\n</code></pre><h4 id=\"2-Master-2-Salve-async\"><a href=\"#2-Master-2-Salve-async\" class=\"headerlink\" title=\"2 Master - 2 Salve async\"></a>2 Master - 2 Salve async</h4><pre><code>TODO\n</code></pre><h4 id=\"2-Master-2-Salve-sync\"><a href=\"#2-Master-2-Salve-sync\" class=\"headerlink\" title=\"2 Master - 2 Salve sync\"></a>2 Master - 2 Salve sync</h4><pre><code>TODO\n</code></pre><h3 id=\"控制台安装-1\"><a href=\"#控制台安装-1\" class=\"headerlink\" title=\"控制台安装\"></a>控制台安装</h3><blockquote>\n<p>控制台使用apache/incubator-rocketmq-externals下的rocketmq-console</p>\n<ul>\n<li>clone：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/apache/incubator-rocketmq-externals.git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>打包</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=localhost:9876</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问控制台：<a href=\"http://localhost:12581\" target=\"_blank\" rel=\"noopener\">http://localhost:12581</a></p>\n</li>\n</ul>\n<h3 id=\"发送消息的默认约定：\"><a href=\"#发送消息的默认约定：\" class=\"headerlink\" title=\"发送消息的默认约定：\"></a>发送消息的默认约定：</h3><ul>\n<li>一个JVM一个MqMessageSender实例，后续视情况是否改为prototype</li>\n<li>默认发送方式为同步 - sendMsg(String, String, String, String)</li>\n<li><p>client没有必要retry</p>\n<blockquote>\n<p>rocketMQ已经有retry, MqMessageSender里也会做必要的失败记录和服务不可用时的retry</p>\n<ul>\n<li>rocketMQ的retry  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultSendingTimeout = 3000 mills</span><br><span class=\"line\">retryTimesWhenSendFailed = 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果发送失败，确保消息不丢失</li>\n<li>MqMessageSender会保存消息到DB，同时抛出unCheckedException<ul>\n<li>（TODO）服务可用后，可以从DB中重新发送</li>\n<li>应用程序接收到Exception后，做必要处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>producerGroup</p>\n<ul>\n<li><p>作用：</p>\n<blockquote>\n<ul>\n<li>标识一类 Producer</li>\n<li>可以通过运维工具查询这个发送消息应用下有多个 Producer 实例</li>\n<li>发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>one producerGroup per application as default</p>\n<blockquote>\n<ul>\n<li>一个 Producer Group 下包含多个 Producer 实例，可以是多台机器， 也可以是一台机器的多个进程，或者一个进程的多个 Producer 对象。</li>\n<li>一个 Producer Group 可以发送多个 Topic 消息.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消费消息的默认约定：\"><a href=\"#消费消息的默认约定：\" class=\"headerlink\" title=\"消费消息的默认约定：\"></a>消费消息的默认约定：</h3><pre><code>TODO\n</code></pre><h3 id=\"并行消息-多线程多Queue-1\"><a href=\"#并行消息-多线程多Queue-1\" class=\"headerlink\" title=\"并行消息(多线程多Queue)\"></a>并行消息(多线程多Queue)</h3><h3 id=\"有序消息-单线程单一ueue-1\"><a href=\"#有序消息-单线程单一ueue-1\" class=\"headerlink\" title=\"有序消息(单线程单一ueue)\"></a>有序消息(单线程单一ueue)</h3><h3 id=\"延迟消息-单线程单一ueue-1\"><a href=\"#延迟消息-单线程单一ueue-1\" class=\"headerlink\" title=\"延迟消息(单线程单一ueue)\"></a>延迟消息(单线程单一ueue)</h3>","site":{"data":{}},"excerpt":"<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><h4 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h4><blockquote>\n<ul>\n<li>1 Master</li>\n<li>2 Master</li>\n<li>2 Master - 2 Salve async</li>\n<li>2 Master - 2 Salve sync            </li>\n</ul>\n</blockquote>\n<h4 id=\"控制台安装\"><a href=\"#控制台安装\" class=\"headerlink\" title=\"控制台安装\"></a>控制台安装</h4><h4 id=\"发送消息的默认约定\"><a href=\"#发送消息的默认约定\" class=\"headerlink\" title=\"发送消息的默认约定\"></a>发送消息的默认约定</h4><h4 id=\"消费消息的默认约定\"><a href=\"#消费消息的默认约定\" class=\"headerlink\" title=\"消费消息的默认约定\"></a>消费消息的默认约定</h4><h4 id=\"并行消息-多线程多Queue\"><a href=\"#并行消息-多线程多Queue\" class=\"headerlink\" title=\"并行消息(多线程多Queue)\"></a>并行消息(多线程多Queue)</h4><h4 id=\"有序消息-单线程单一ueue\"><a href=\"#有序消息-单线程单一ueue\" class=\"headerlink\" title=\"有序消息(单线程单一ueue)\"></a>有序消息(单线程单一ueue)</h4><h4 id=\"延迟消息-单线程单一ueue\"><a href=\"#延迟消息-单线程单一ueue\" class=\"headerlink\" title=\"延迟消息(单线程单一ueue)\"></a>延迟消息(单线程单一ueue)</h4>","more":"<hr>\n<h3 id=\"部署-1\"><a href=\"#部署-1\" class=\"headerlink\" title=\"部署\"></a>部署</h3><pre><code>下载并解压[rocketmq](http://mirrors.tuna.tsinghua.edu.cn/apache/incubator/rocketmq/4.0.0-incubating/rocketmq-all-4.0.0-incubating-bin-release.zip )\n</code></pre><h4 id=\"1-Master\"><a href=\"#1-Master\" class=\"headerlink\" title=\"1 Master\"></a>1 Master</h4><ul>\n<li><p>启动nameServer</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqnamesrv &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动broker</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nohup sh bin/mqbroker -n localhost:9876 -c conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>shutdown</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/mqshutdown broker</span><br><span class=\"line\">bin/mqshutdown namesrv</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"2-Master\"><a href=\"#2-Master\" class=\"headerlink\" title=\"2 Master\"></a>2 Master</h4><pre><code>TODO\n</code></pre><h4 id=\"2-Master-2-Salve-async\"><a href=\"#2-Master-2-Salve-async\" class=\"headerlink\" title=\"2 Master - 2 Salve async\"></a>2 Master - 2 Salve async</h4><pre><code>TODO\n</code></pre><h4 id=\"2-Master-2-Salve-sync\"><a href=\"#2-Master-2-Salve-sync\" class=\"headerlink\" title=\"2 Master - 2 Salve sync\"></a>2 Master - 2 Salve sync</h4><pre><code>TODO\n</code></pre><h3 id=\"控制台安装-1\"><a href=\"#控制台安装-1\" class=\"headerlink\" title=\"控制台安装\"></a>控制台安装</h3><blockquote>\n<p>控制台使用apache/incubator-rocketmq-externals下的rocketmq-console</p>\n<ul>\n<li>clone：  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/apache/incubator-rocketmq-externals.git</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li><p>打包</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>启动</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar rocketmq-console-ng-1.0.0.jar --server.port=12581 --rocketmq.config.namesrvAddr=localhost:9876</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问控制台：<a href=\"http://localhost:12581\" target=\"_blank\" rel=\"noopener\">http://localhost:12581</a></p>\n</li>\n</ul>\n<h3 id=\"发送消息的默认约定：\"><a href=\"#发送消息的默认约定：\" class=\"headerlink\" title=\"发送消息的默认约定：\"></a>发送消息的默认约定：</h3><ul>\n<li>一个JVM一个MqMessageSender实例，后续视情况是否改为prototype</li>\n<li>默认发送方式为同步 - sendMsg(String, String, String, String)</li>\n<li><p>client没有必要retry</p>\n<blockquote>\n<p>rocketMQ已经有retry, MqMessageSender里也会做必要的失败记录和服务不可用时的retry</p>\n<ul>\n<li>rocketMQ的retry  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">defaultSendingTimeout = 3000 mills</span><br><span class=\"line\">retryTimesWhenSendFailed = 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>如果发送失败，确保消息不丢失</li>\n<li>MqMessageSender会保存消息到DB，同时抛出unCheckedException<ul>\n<li>（TODO）服务可用后，可以从DB中重新发送</li>\n<li>应用程序接收到Exception后，做必要处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>producerGroup</p>\n<ul>\n<li><p>作用：</p>\n<blockquote>\n<ul>\n<li>标识一类 Producer</li>\n<li>可以通过运维工具查询这个发送消息应用下有多个 Producer 实例</li>\n<li>发送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主动回调 Producer Group 内的任意一台机器来确认事务状态。</li>\n</ul>\n</blockquote>\n</li>\n<li><p>one producerGroup per application as default</p>\n<blockquote>\n<ul>\n<li>一个 Producer Group 下包含多个 Producer 实例，可以是多台机器， 也可以是一台机器的多个进程，或者一个进程的多个 Producer 对象。</li>\n<li>一个 Producer Group 可以发送多个 Topic 消息.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"消费消息的默认约定：\"><a href=\"#消费消息的默认约定：\" class=\"headerlink\" title=\"消费消息的默认约定：\"></a>消费消息的默认约定：</h3><pre><code>TODO\n</code></pre><h3 id=\"并行消息-多线程多Queue-1\"><a href=\"#并行消息-多线程多Queue-1\" class=\"headerlink\" title=\"并行消息(多线程多Queue)\"></a>并行消息(多线程多Queue)</h3><h3 id=\"有序消息-单线程单一ueue-1\"><a href=\"#有序消息-单线程单一ueue-1\" class=\"headerlink\" title=\"有序消息(单线程单一ueue)\"></a>有序消息(单线程单一ueue)</h3><h3 id=\"延迟消息-单线程单一ueue-1\"><a href=\"#延迟消息-单线程单一ueue-1\" class=\"headerlink\" title=\"延迟消息(单线程单一ueue)\"></a>延迟消息(单线程单一ueue)</h3>"},{"title":"RocketMq实战","date":"2018-03-29T14:59:15.000Z","_content":"    将RocketMQ的producer和listner封装成sender和consumer，力求简单实用。\n    源码：https://github.com/jisumanbu/RocketMqInAction.git\n\n## 发送消息\n    封装类为：MqMessageSender，支持以下多种发送方式及异常处理\n * 同步和异步发送消息\n * 发送有序消息\n * 延迟发送消息\n * 异常处理\n   > 失败重试\n\n## 接收并消费消息\n    分为ConcurrentlyConsumer和OrderlyConsumer。\n * 有序消息 -> 继承OrderlyConsumer   \n * 非有序消息 -> 可认为支持多线程, 继承ConcurrentlyConsumer\n## 自动过滤重复消息，避免重复消费问题\n    具体实现：AbstractConsumer.isAlreadyConsumed(...)方法。\n * 利用redisson的RSetCache类的add特性来判断消息是否已经消费过了    \n * true if value has been added. false if value already been in collection.\n    ```java\n    isAlreadyConsumed = !FedisClient.getClient().getSetCache(hashKeyOfRedis).add(messageKey, 1L, TimeUnit.DAYS);\n    ```\n    > 注意：FedisClient为未实现单例，用户得自行修复以上代码。\n    \n<!-- more --> ","source":"_posts/rocketMq-in-action.md","raw":"---\ntitle: RocketMq实战\ndate: 2018-03-29 22:59:15\ncategories: \n- MQ\n- RocketMQ\ntags:\n- MQ\n- RocketMQ\n---\n    将RocketMQ的producer和listner封装成sender和consumer，力求简单实用。\n    源码：https://github.com/jisumanbu/RocketMqInAction.git\n\n## 发送消息\n    封装类为：MqMessageSender，支持以下多种发送方式及异常处理\n * 同步和异步发送消息\n * 发送有序消息\n * 延迟发送消息\n * 异常处理\n   > 失败重试\n\n## 接收并消费消息\n    分为ConcurrentlyConsumer和OrderlyConsumer。\n * 有序消息 -> 继承OrderlyConsumer   \n * 非有序消息 -> 可认为支持多线程, 继承ConcurrentlyConsumer\n## 自动过滤重复消息，避免重复消费问题\n    具体实现：AbstractConsumer.isAlreadyConsumed(...)方法。\n * 利用redisson的RSetCache类的add特性来判断消息是否已经消费过了    \n * true if value has been added. false if value already been in collection.\n    ```java\n    isAlreadyConsumed = !FedisClient.getClient().getSetCache(hashKeyOfRedis).add(messageKey, 1L, TimeUnit.DAYS);\n    ```\n    > 注意：FedisClient为未实现单例，用户得自行修复以上代码。\n    \n<!-- more --> ","slug":"rocketMq-in-action","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0h000f9t9cncwrc9b9","content":"<pre><code>将RocketMQ的producer和listner封装成sender和consumer，力求简单实用。\n源码：https://github.com/jisumanbu/RocketMqInAction.git\n</code></pre><h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><pre><code>封装类为：MqMessageSender，支持以下多种发送方式及异常处理\n</code></pre><ul>\n<li>同步和异步发送消息</li>\n<li>发送有序消息</li>\n<li>延迟发送消息</li>\n<li>异常处理<blockquote>\n<p>失败重试</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"接收并消费消息\"><a href=\"#接收并消费消息\" class=\"headerlink\" title=\"接收并消费消息\"></a>接收并消费消息</h2><pre><code>分为ConcurrentlyConsumer和OrderlyConsumer。\n</code></pre><ul>\n<li>有序消息 -&gt; 继承OrderlyConsumer   </li>\n<li>非有序消息 -&gt; 可认为支持多线程, 继承ConcurrentlyConsumer<h2 id=\"自动过滤重复消息，避免重复消费问题\"><a href=\"#自动过滤重复消息，避免重复消费问题\" class=\"headerlink\" title=\"自动过滤重复消息，避免重复消费问题\"></a>自动过滤重复消息，避免重复消费问题</h2> 具体实现：AbstractConsumer.isAlreadyConsumed(…)方法。</li>\n<li>利用redisson的RSetCache类的add特性来判断消息是否已经消费过了    </li>\n<li><p>true if value has been added. false if value already been in collection.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isAlreadyConsumed = !FedisClient.getClient().getSetCache(hashKeyOfRedis).add(messageKey, <span class=\"number\">1L</span>, TimeUnit.DAYS);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：FedisClient为未实现单例，用户得自行修复以上代码。</p>\n</blockquote>\n</li>\n</ul>\n<a id=\"more\"></a> ","site":{"data":{}},"excerpt":"<pre><code>将RocketMQ的producer和listner封装成sender和consumer，力求简单实用。\n源码：https://github.com/jisumanbu/RocketMqInAction.git\n</code></pre><h2 id=\"发送消息\"><a href=\"#发送消息\" class=\"headerlink\" title=\"发送消息\"></a>发送消息</h2><pre><code>封装类为：MqMessageSender，支持以下多种发送方式及异常处理\n</code></pre><ul>\n<li>同步和异步发送消息</li>\n<li>发送有序消息</li>\n<li>延迟发送消息</li>\n<li>异常处理<blockquote>\n<p>失败重试</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"接收并消费消息\"><a href=\"#接收并消费消息\" class=\"headerlink\" title=\"接收并消费消息\"></a>接收并消费消息</h2><pre><code>分为ConcurrentlyConsumer和OrderlyConsumer。\n</code></pre><ul>\n<li>有序消息 -&gt; 继承OrderlyConsumer   </li>\n<li>非有序消息 -&gt; 可认为支持多线程, 继承ConcurrentlyConsumer<h2 id=\"自动过滤重复消息，避免重复消费问题\"><a href=\"#自动过滤重复消息，避免重复消费问题\" class=\"headerlink\" title=\"自动过滤重复消息，避免重复消费问题\"></a>自动过滤重复消息，避免重复消费问题</h2> 具体实现：AbstractConsumer.isAlreadyConsumed(…)方法。</li>\n<li>利用redisson的RSetCache类的add特性来判断消息是否已经消费过了    </li>\n<li><p>true if value has been added. false if value already been in collection.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isAlreadyConsumed = !FedisClient.getClient().getSetCache(hashKeyOfRedis).add(messageKey, <span class=\"number\">1L</span>, TimeUnit.DAYS);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：FedisClient为未实现单例，用户得自行修复以上代码。</p>\n</blockquote>\n</li>\n</ul>","more":""},{"title":"RocketMQ一基本概念","date":"2018-03-13T16:21:26.000Z","_content":"###### contents\n>1. Main Concepts\n>>* nameServer\n>>* Broker\n>>* producer\n>>* consumer\n>>* group\n>\n>2. 同步 - 异步\n>3. 安装\n>>* 单机\n>>* 主从\n>\n>4. 控制台\n>>1. mqadmin\n>>2. 控制台(rocketMq-console)\n<!--more-->\n#### Main Concepts\n##### nameServer\n> TODO\n\n##### broker\n> TODO\n\n##### producer\n* 生产者端的负载均衡（生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上）\n    * 假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息\n\n\n* ProducerGroupName\n  For non-transactional messages, it does not matter as long as it's unique per process.\n  * nameSrv\n","source":"_posts/rocketMQ-1-concepts.md","raw":"---\ntitle: RocketMQ一基本概念\ndate: 2018-03-14 00:21:26\ncategories: \n- MQ\n- RocketMQ\ntags:\n- MQ\n- RocketMQ\n---\n###### contents\n>1. Main Concepts\n>>* nameServer\n>>* Broker\n>>* producer\n>>* consumer\n>>* group\n>\n>2. 同步 - 异步\n>3. 安装\n>>* 单机\n>>* 主从\n>\n>4. 控制台\n>>1. mqadmin\n>>2. 控制台(rocketMq-console)\n<!--more-->\n#### Main Concepts\n##### nameServer\n> TODO\n\n##### broker\n> TODO\n\n##### producer\n* 生产者端的负载均衡（生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上）\n    * 假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息\n\n\n* ProducerGroupName\n  For non-transactional messages, it does not matter as long as it's unique per process.\n  * nameSrv\n","slug":"rocketMQ-1-concepts","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0i000h9t9c9l2pri5g","content":"<h6 id=\"contents\"><a href=\"#contents\" class=\"headerlink\" title=\"contents\"></a>contents</h6><blockquote>\n<ol>\n<li><p>Main Concepts</p>\n<blockquote>\n<ul>\n<li>nameServer</li>\n<li>Broker</li>\n<li>producer</li>\n<li>consumer</li>\n<li>group</li>\n</ul>\n</blockquote>\n</li>\n<li><p>同步 - 异步</p>\n</li>\n<li><p>安装</p>\n<blockquote>\n<ul>\n<li>单机</li>\n<li>主从</li>\n</ul>\n</blockquote>\n</li>\n<li><p>控制台</p>\n<blockquote>\n<ol>\n<li>mqadmin</li>\n<li>控制台(rocketMq-console)<a id=\"more\"></a>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"Main-Concepts\"><a href=\"#Main-Concepts\" class=\"headerlink\" title=\"Main Concepts\"></a>Main Concepts</h4><h5 id=\"nameServer\"><a href=\"#nameServer\" class=\"headerlink\" title=\"nameServer\"></a>nameServer</h5><blockquote>\n<p>TODO</p>\n</blockquote>\n<h5 id=\"broker\"><a href=\"#broker\" class=\"headerlink\" title=\"broker\"></a>broker</h5><blockquote>\n<p>TODO</p>\n</blockquote>\n<h5 id=\"producer\"><a href=\"#producer\" class=\"headerlink\" title=\"producer\"></a>producer</h5><ul>\n<li>生产者端的负载均衡（生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上）<ul>\n<li>假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>ProducerGroupName<br>For non-transactional messages, it does not matter as long as it’s unique per process.<ul>\n<li>nameSrv</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h6 id=\"contents\"><a href=\"#contents\" class=\"headerlink\" title=\"contents\"></a>contents</h6><blockquote>\n<ol>\n<li><p>Main Concepts</p>\n<blockquote>\n<ul>\n<li>nameServer</li>\n<li>Broker</li>\n<li>producer</li>\n<li>consumer</li>\n<li>group</li>\n</ul>\n</blockquote>\n</li>\n<li><p>同步 - 异步</p>\n</li>\n<li><p>安装</p>\n<blockquote>\n<ul>\n<li>单机</li>\n<li>主从</li>\n</ul>\n</blockquote>\n</li>\n<li><p>控制台</p>\n<blockquote>\n<ol>\n<li>mqadmin</li>\n<li>控制台(rocketMq-console)","more":"</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"Main-Concepts\"><a href=\"#Main-Concepts\" class=\"headerlink\" title=\"Main Concepts\"></a>Main Concepts</h4><h5 id=\"nameServer\"><a href=\"#nameServer\" class=\"headerlink\" title=\"nameServer\"></a>nameServer</h5><blockquote>\n<p>TODO</p>\n</blockquote>\n<h5 id=\"broker\"><a href=\"#broker\" class=\"headerlink\" title=\"broker\"></a>broker</h5><blockquote>\n<p>TODO</p>\n</blockquote>\n<h5 id=\"producer\"><a href=\"#producer\" class=\"headerlink\" title=\"producer\"></a>producer</h5><ul>\n<li>生产者端的负载均衡（生产者发送时，会自动轮询当前所有可发送的broker，一条消息发送成功，下次换另外一个broker发送，以达到消息平均落到所有的broker上）<ul>\n<li>假如某个Broker宕机，意味生产者最长需要30秒才能感知到。在这期间会向宕机的Broker发送消息</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>ProducerGroupName<br>For non-transactional messages, it does not matter as long as it’s unique per process.<ul>\n<li>nameSrv</li>\n</ul>\n</li>\n</ul>"},{"title":"怎样才能生活得更好-读奇特的一生","date":"2018-04-05T14:43:09.000Z","_content":"\n《奇特的一生》以个人传记的方式讲述了柳比歇夫的时间管理法。按照作者的逻辑去读这本书的话，很难抓住重点，\n正如作者自己所言\"作者仍然不能做出最后的结论，给读者出点什么主意\"。\n比如，全书的中心是\"怎样才能生活的更好\"，但是全文又都是在写柳比歇夫的\"时间统计法\"，他们之间的逻辑是什么样的？\n我们有必要或如何将时间统计法应用到我们的生活中？\n\n\"时间统计法\"本质上是时间管理的一种方式和工具，它服务于目标管理，帮助我们更好的完成我们的人生目标。\n下面本文就将以\"目标驱动\"的逻辑来重新梳理《奇特的一生》，弄明白\"怎样才能生活的更好\"。\n<!-- more --> \n\n### 怎样算作生活的更好\n    以主人公柳比歇夫为例，清楚自己活着的目的，并终生为自己的目标奋斗，最终活出了个\"令人惊叹的一生\"。\n #### 魅力表现\n > \n * 目标明确！知道活着是为了什么，有什么目的\n    > 仿佛有什么崇高的目的，甚至可能领悟了存在的意义。   \n    作为榜样，教人应当怎样生活、怎样思考\n * \n\n### 本文导图\n![奇特的一生](/images/怎样才能生活得更好.pdf)\n","source":"_posts/怎样才能生活得更好-奇特的一生读书笔记.md","raw":"---\ntitle: 怎样才能生活得更好-读奇特的一生\ndate: 2018-04-05 22:43:09\ncategories: \n- 目标驱动\ntags:\n- 目标驱动\n- 时间管理\n---\n\n《奇特的一生》以个人传记的方式讲述了柳比歇夫的时间管理法。按照作者的逻辑去读这本书的话，很难抓住重点，\n正如作者自己所言\"作者仍然不能做出最后的结论，给读者出点什么主意\"。\n比如，全书的中心是\"怎样才能生活的更好\"，但是全文又都是在写柳比歇夫的\"时间统计法\"，他们之间的逻辑是什么样的？\n我们有必要或如何将时间统计法应用到我们的生活中？\n\n\"时间统计法\"本质上是时间管理的一种方式和工具，它服务于目标管理，帮助我们更好的完成我们的人生目标。\n下面本文就将以\"目标驱动\"的逻辑来重新梳理《奇特的一生》，弄明白\"怎样才能生活的更好\"。\n<!-- more --> \n\n### 怎样算作生活的更好\n    以主人公柳比歇夫为例，清楚自己活着的目的，并终生为自己的目标奋斗，最终活出了个\"令人惊叹的一生\"。\n #### 魅力表现\n > \n * 目标明确！知道活着是为了什么，有什么目的\n    > 仿佛有什么崇高的目的，甚至可能领悟了存在的意义。   \n    作为榜样，教人应当怎样生活、怎样思考\n * \n\n### 本文导图\n![奇特的一生](/images/怎样才能生活得更好.pdf)\n","slug":"怎样才能生活得更好-奇特的一生读书笔记","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0j000m9t9c2eqkcwe7","content":"<p>《奇特的一生》以个人传记的方式讲述了柳比歇夫的时间管理法。按照作者的逻辑去读这本书的话，很难抓住重点，<br>正如作者自己所言”作者仍然不能做出最后的结论，给读者出点什么主意”。<br>比如，全书的中心是”怎样才能生活的更好”，但是全文又都是在写柳比歇夫的”时间统计法”，他们之间的逻辑是什么样的？<br>我们有必要或如何将时间统计法应用到我们的生活中？</p>\n<p>“时间统计法”本质上是时间管理的一种方式和工具，它服务于目标管理，帮助我们更好的完成我们的人生目标。<br>下面本文就将以”目标驱动”的逻辑来重新梳理《奇特的一生》，弄明白”怎样才能生活的更好”。<br><a id=\"more\"></a> </p>\n<h3 id=\"怎样算作生活的更好\"><a href=\"#怎样算作生活的更好\" class=\"headerlink\" title=\"怎样算作生活的更好\"></a>怎样算作生活的更好</h3><pre><code>以主人公柳比歇夫为例，清楚自己活着的目的，并终生为自己的目标奋斗，最终活出了个&quot;令人惊叹的一生&quot;。\n</code></pre><h4 id=\"魅力表现\"><a href=\"#魅力表现\" class=\"headerlink\" title=\"魅力表现\"></a>魅力表现</h4><blockquote>\n</blockquote>\n<ul>\n<li>目标明确！知道活着是为了什么，有什么目的<blockquote>\n<p>仿佛有什么崇高的目的，甚至可能领悟了存在的意义。<br> 作为榜样，教人应当怎样生活、怎样思考</p>\n</blockquote>\n</li>\n<li></li>\n</ul>\n<h3 id=\"本文导图\"><a href=\"#本文导图\" class=\"headerlink\" title=\"本文导图\"></a>本文导图</h3><p><img src=\"/images/怎样才能生活得更好.pdf\" alt=\"奇特的一生\"></p>\n","site":{"data":{}},"excerpt":"<p>《奇特的一生》以个人传记的方式讲述了柳比歇夫的时间管理法。按照作者的逻辑去读这本书的话，很难抓住重点，<br>正如作者自己所言”作者仍然不能做出最后的结论，给读者出点什么主意”。<br>比如，全书的中心是”怎样才能生活的更好”，但是全文又都是在写柳比歇夫的”时间统计法”，他们之间的逻辑是什么样的？<br>我们有必要或如何将时间统计法应用到我们的生活中？</p>\n<p>“时间统计法”本质上是时间管理的一种方式和工具，它服务于目标管理，帮助我们更好的完成我们的人生目标。<br>下面本文就将以”目标驱动”的逻辑来重新梳理《奇特的一生》，弄明白”怎样才能生活的更好”。<br>","more":"</p>\n<h3 id=\"怎样算作生活的更好\"><a href=\"#怎样算作生活的更好\" class=\"headerlink\" title=\"怎样算作生活的更好\"></a>怎样算作生活的更好</h3><pre><code>以主人公柳比歇夫为例，清楚自己活着的目的，并终生为自己的目标奋斗，最终活出了个&quot;令人惊叹的一生&quot;。\n</code></pre><h4 id=\"魅力表现\"><a href=\"#魅力表现\" class=\"headerlink\" title=\"魅力表现\"></a>魅力表现</h4><blockquote>\n</blockquote>\n<ul>\n<li>目标明确！知道活着是为了什么，有什么目的<blockquote>\n<p>仿佛有什么崇高的目的，甚至可能领悟了存在的意义。<br> 作为榜样，教人应当怎样生活、怎样思考</p>\n</blockquote>\n</li>\n<li></li>\n</ul>\n<h3 id=\"本文导图\"><a href=\"#本文导图\" class=\"headerlink\" title=\"本文导图\"></a>本文导图</h3><p><img src=\"/images/怎样才能生活得更好.pdf\" alt=\"奇特的一生\"></p>"},{"title":"大规模分布式存储系统-原理解析与架构实战","date":"2018-03-11T16:00:00.000Z","_content":"\n第2章 单机存储系统\n* 2.1 硬件基础\n* 2.1.1 CPU架构\n    * CMP & NUMA\n* 2.1.2 IO总线\n    * 主板的南北桥架构\n* 2.1.3 网络拓扑\n    * 三层结构：接入层／汇聚层／核心层\n    * 三级CLOS网络（扁平化结构）\n* 2.1.4 性能参数\n* 2.1.5 存储层次架构\n    * 集群->机架->单机\n    * 存储系统的性能维度：吞吐量，访问延时。\n* 2.2 单机存储引擎\n* 2.2.1 哈希存储引擎\n    * Bitcask -> 基于哈希表结构的键值存储系统，仅支持追加操作；文件大小有限制\n    * 数据结构\n    * 定期合并\n    * 快速恢复\n<!--more-->\n* 2.2.2 B树存储引擎\n* 2.4 事务与并发控制\n    * 事务的并发通过锁来实现\n    * 提高读事务性能\n        * 写时复制（copy on write）\n        * 多版本并发控制 （Multi-version concurrency control)\n    * 2.4.1 事务\n    * 2.4.2 并发控制\n        * 数据库锁\n            * 发散课题 -> read committed & read committed snapshot & repeated read & MVCC的区别与实现\n            * 解决死锁的思路\n                * 为事务设置超时回滚\n                * 死锁检测，检测到死锁后回滚\n        * 写时复制，无锁\n            * 用SNAPSHOT代替锁\n                * 无锁，写不影响读\n                * snapshot的生成成本高\n                * 写互斥\n                [写时复制B+树](/images/写时复制B+树.png)\n        * 多版本并发控制，无锁\n            * 两个隐藏列\n                * 行被修改时的版本\n                * 行被删除时的版本","source":"_posts/大规模分布式存储系统-原理解析与架构实战.md","raw":"---\ntitle: 大规模分布式存储系统-原理解析与架构实战\ndate: 2018-03-12\ncategories: \n- Storage\ntags:\n- 分布式\n- 存储\n---\n\n第2章 单机存储系统\n* 2.1 硬件基础\n* 2.1.1 CPU架构\n    * CMP & NUMA\n* 2.1.2 IO总线\n    * 主板的南北桥架构\n* 2.1.3 网络拓扑\n    * 三层结构：接入层／汇聚层／核心层\n    * 三级CLOS网络（扁平化结构）\n* 2.1.4 性能参数\n* 2.1.5 存储层次架构\n    * 集群->机架->单机\n    * 存储系统的性能维度：吞吐量，访问延时。\n* 2.2 单机存储引擎\n* 2.2.1 哈希存储引擎\n    * Bitcask -> 基于哈希表结构的键值存储系统，仅支持追加操作；文件大小有限制\n    * 数据结构\n    * 定期合并\n    * 快速恢复\n<!--more-->\n* 2.2.2 B树存储引擎\n* 2.4 事务与并发控制\n    * 事务的并发通过锁来实现\n    * 提高读事务性能\n        * 写时复制（copy on write）\n        * 多版本并发控制 （Multi-version concurrency control)\n    * 2.4.1 事务\n    * 2.4.2 并发控制\n        * 数据库锁\n            * 发散课题 -> read committed & read committed snapshot & repeated read & MVCC的区别与实现\n            * 解决死锁的思路\n                * 为事务设置超时回滚\n                * 死锁检测，检测到死锁后回滚\n        * 写时复制，无锁\n            * 用SNAPSHOT代替锁\n                * 无锁，写不影响读\n                * snapshot的生成成本高\n                * 写互斥\n                [写时复制B+树](/images/写时复制B+树.png)\n        * 多版本并发控制，无锁\n            * 两个隐藏列\n                * 行被修改时的版本\n                * 行被删除时的版本","slug":"大规模分布式存储系统-原理解析与架构实战","published":1,"updated":"2018-04-07T03:54:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjfowdc0l000o9t9c31szph4f","content":"<p>第2章 单机存储系统</p>\n<ul>\n<li>2.1 硬件基础</li>\n<li>2.1.1 CPU架构<ul>\n<li>CMP &amp; NUMA</li>\n</ul>\n</li>\n<li>2.1.2 IO总线<ul>\n<li>主板的南北桥架构</li>\n</ul>\n</li>\n<li>2.1.3 网络拓扑<ul>\n<li>三层结构：接入层／汇聚层／核心层</li>\n<li>三级CLOS网络（扁平化结构）</li>\n</ul>\n</li>\n<li>2.1.4 性能参数</li>\n<li>2.1.5 存储层次架构<ul>\n<li>集群-&gt;机架-&gt;单机</li>\n<li>存储系统的性能维度：吞吐量，访问延时。</li>\n</ul>\n</li>\n<li>2.2 单机存储引擎</li>\n<li>2.2.1 哈希存储引擎<ul>\n<li>Bitcask -&gt; 基于哈希表结构的键值存储系统，仅支持追加操作；文件大小有限制</li>\n<li>数据结构</li>\n<li>定期合并</li>\n<li>快速恢复<a id=\"more\"></a></li>\n</ul>\n</li>\n<li>2.2.2 B树存储引擎</li>\n<li>2.4 事务与并发控制<ul>\n<li>事务的并发通过锁来实现</li>\n<li>提高读事务性能<ul>\n<li>写时复制（copy on write）</li>\n<li>多版本并发控制 （Multi-version concurrency control)</li>\n</ul>\n</li>\n<li>2.4.1 事务</li>\n<li>2.4.2 并发控制<ul>\n<li>数据库锁<ul>\n<li>发散课题 -&gt; read committed &amp; read committed snapshot &amp; repeated read &amp; MVCC的区别与实现</li>\n<li>解决死锁的思路<ul>\n<li>为事务设置超时回滚</li>\n<li>死锁检测，检测到死锁后回滚</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>写时复制，无锁<ul>\n<li>用SNAPSHOT代替锁<ul>\n<li>无锁，写不影响读</li>\n<li>snapshot的生成成本高</li>\n<li>写互斥<br><a href=\"/images/写时复制B+树.png\">写时复制B+树</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多版本并发控制，无锁<ul>\n<li>两个隐藏列<ul>\n<li>行被修改时的版本</li>\n<li>行被删除时的版本</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>第2章 单机存储系统</p>\n<ul>\n<li>2.1 硬件基础</li>\n<li>2.1.1 CPU架构<ul>\n<li>CMP &amp; NUMA</li>\n</ul>\n</li>\n<li>2.1.2 IO总线<ul>\n<li>主板的南北桥架构</li>\n</ul>\n</li>\n<li>2.1.3 网络拓扑<ul>\n<li>三层结构：接入层／汇聚层／核心层</li>\n<li>三级CLOS网络（扁平化结构）</li>\n</ul>\n</li>\n<li>2.1.4 性能参数</li>\n<li>2.1.5 存储层次架构<ul>\n<li>集群-&gt;机架-&gt;单机</li>\n<li>存储系统的性能维度：吞吐量，访问延时。</li>\n</ul>\n</li>\n<li>2.2 单机存储引擎</li>\n<li>2.2.1 哈希存储引擎<ul>\n<li>Bitcask -&gt; 基于哈希表结构的键值存储系统，仅支持追加操作；文件大小有限制</li>\n<li>数据结构</li>\n<li>定期合并</li>\n<li>快速恢复","more":"</li>\n</ul>\n</li>\n<li>2.2.2 B树存储引擎</li>\n<li>2.4 事务与并发控制<ul>\n<li>事务的并发通过锁来实现</li>\n<li>提高读事务性能<ul>\n<li>写时复制（copy on write）</li>\n<li>多版本并发控制 （Multi-version concurrency control)</li>\n</ul>\n</li>\n<li>2.4.1 事务</li>\n<li>2.4.2 并发控制<ul>\n<li>数据库锁<ul>\n<li>发散课题 -&gt; read committed &amp; read committed snapshot &amp; repeated read &amp; MVCC的区别与实现</li>\n<li>解决死锁的思路<ul>\n<li>为事务设置超时回滚</li>\n<li>死锁检测，检测到死锁后回滚</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>写时复制，无锁<ul>\n<li>用SNAPSHOT代替锁<ul>\n<li>无锁，写不影响读</li>\n<li>snapshot的生成成本高</li>\n<li>写互斥<br><a href=\"/images/写时复制B+树.png\">写时复制B+树</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多版本并发控制，无锁<ul>\n<li>两个隐藏列<ul>\n<li>行被修改时的版本</li>\n<li>行被删除时的版本</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjfowdc0300029t9cxl20tizn","category_id":"cjfowdc0d00099t9cuwmc2k17","_id":"cjfowdc0j000j9t9c34u2lcin"},{"post_id":"cjfowdc0900069t9cehpfhgib","category_id":"cjfowdc0g000d9t9c5zycyng4","_id":"cjfowdc0m000p9t9cllasfvl9"},{"post_id":"cjfowdc0b00079t9cor6izyol","category_id":"cjfowdc0j000k9t9cibura9y9","_id":"cjfowdc0n000t9t9cxs2xvkzo"},{"post_id":"cjfowdbzy00009t9c0kyyh0dp","category_id":"cjfowdc0800049t9cgwdsxmid","_id":"cjfowdc0n000x9t9c9l0da1d8"},{"post_id":"cjfowdbzy00009t9c0kyyh0dp","category_id":"cjfowdc0m000q9t9c5ylejq3x","_id":"cjfowdc0o00109t9cnu1xabuj"},{"post_id":"cjfowdc0c00089t9c85yxhg6f","category_id":"cjfowdc0n000u9t9cpwaiyk2j","_id":"cjfowdc0o00119t9crlf2d7wp"},{"post_id":"cjfowdc0d000b9t9cbdnupdqw","category_id":"cjfowdc0n000y9t9cfjb5xyln","_id":"cjfowdc0s00179t9c8ao8ihyt"},{"post_id":"cjfowdc0j000m9t9c2eqkcwe7","category_id":"cjfowdc0u001c9t9cjuxxxxwu","_id":"cjfowdc0y001j9t9cxt81c9uu"},{"post_id":"cjfowdc0l000o9t9c31szph4f","category_id":"cjfowdc0v001f9t9cyqg06i9v","_id":"cjfowdc0z001n9t9c47x1kgd6"},{"post_id":"cjfowdc0e000c9t9cwn50t4h5","category_id":"cjfowdc0n000u9t9cpwaiyk2j","_id":"cjfowdc10001t9t9chsf6n1a7"},{"post_id":"cjfowdc0e000c9t9cwn50t4h5","category_id":"cjfowdc0y001l9t9ctysp4sau","_id":"cjfowdc10001u9t9cku7xn8uj"},{"post_id":"cjfowdc0h000f9t9cncwrc9b9","category_id":"cjfowdc0n000u9t9cpwaiyk2j","_id":"cjfowdc10001v9t9cbzz58va2"},{"post_id":"cjfowdc0h000f9t9cncwrc9b9","category_id":"cjfowdc0y001l9t9ctysp4sau","_id":"cjfowdc11001y9t9cgn5k3buw"},{"post_id":"cjfowdc0i000h9t9c9l2pri5g","category_id":"cjfowdc0n000u9t9cpwaiyk2j","_id":"cjfowdc1100209t9c3dejsnae"},{"post_id":"cjfowdc0i000h9t9c9l2pri5g","category_id":"cjfowdc0y001l9t9ctysp4sau","_id":"cjfowdc1200229t9cq60k4dds"}],"PostTag":[{"post_id":"cjfowdbzy00009t9c0kyyh0dp","tag_id":"cjfowdc0900059t9c6tbeipos","_id":"cjfowdc0h000g9t9cph774nun"},{"post_id":"cjfowdbzy00009t9c0kyyh0dp","tag_id":"cjfowdc0d000a9t9c42ryu07d","_id":"cjfowdc0i000i9t9ch2g5tq41"},{"post_id":"cjfowdc0900069t9cehpfhgib","tag_id":"cjfowdc0g000e9t9cd9fr4f2o","_id":"cjfowdc0k000n9t9cspdjjuur"},{"post_id":"cjfowdc0b00079t9cor6izyol","tag_id":"cjfowdc0j000l9t9cxouowtzv","_id":"cjfowdc0m000s9t9ckd6fns0b"},{"post_id":"cjfowdc0c00089t9c85yxhg6f","tag_id":"cjfowdc0m000r9t9chzgtqhoz","_id":"cjfowdc0n000w9t9c4n75fvda"},{"post_id":"cjfowdc0d000b9t9cbdnupdqw","tag_id":"cjfowdc0n000v9t9cqn4zutp2","_id":"cjfowdc0r00149t9c3xhns5oz"},{"post_id":"cjfowdc0d000b9t9cbdnupdqw","tag_id":"cjfowdc0o000z9t9cs93ey3wp","_id":"cjfowdc0r00159t9ckx7qtfod"},{"post_id":"cjfowdc0e000c9t9cwn50t4h5","tag_id":"cjfowdc0m000r9t9chzgtqhoz","_id":"cjfowdc0t001b9t9c570dchmi"},{"post_id":"cjfowdc0e000c9t9cwn50t4h5","tag_id":"cjfowdc0s00189t9cq6ophj4i","_id":"cjfowdc0u001d9t9c4658c88t"},{"post_id":"cjfowdc0h000f9t9cncwrc9b9","tag_id":"cjfowdc0m000r9t9chzgtqhoz","_id":"cjfowdc0x001h9t9cu5971lkr"},{"post_id":"cjfowdc0h000f9t9cncwrc9b9","tag_id":"cjfowdc0s00189t9cq6ophj4i","_id":"cjfowdc0x001i9t9c0fpb9zyn"},{"post_id":"cjfowdc0i000h9t9c9l2pri5g","tag_id":"cjfowdc0m000r9t9chzgtqhoz","_id":"cjfowdc0z001p9t9c0pxiyali"},{"post_id":"cjfowdc0i000h9t9c9l2pri5g","tag_id":"cjfowdc0s00189t9cq6ophj4i","_id":"cjfowdc0z001q9t9cj6kd5os5"},{"post_id":"cjfowdc0j000m9t9c2eqkcwe7","tag_id":"cjfowdc0y001m9t9cx20l536b","_id":"cjfowdc11001x9t9cmhhazbpo"},{"post_id":"cjfowdc0j000m9t9c2eqkcwe7","tag_id":"cjfowdc0z001r9t9c8ddx61l5","_id":"cjfowdc11001z9t9cb5pyn5tg"},{"post_id":"cjfowdc0l000o9t9c31szph4f","tag_id":"cjfowdc10001w9t9cihkc7j0n","_id":"cjfowdc1200239t9c771p5oqd"},{"post_id":"cjfowdc0l000o9t9c31szph4f","tag_id":"cjfowdc1100219t9cicw2k6ls","_id":"cjfowdc1200249t9c0np1ij6u"}],"Tag":[{"name":"HTTPS","_id":"cjfowdc0900059t9c6tbeipos"},{"name":"JWT","_id":"cjfowdc0d000a9t9c42ryu07d"},{"name":"Redis","_id":"cjfowdc0g000e9t9cd9fr4f2o"},{"name":"strategy","_id":"cjfowdc0j000l9t9cxouowtzv"},{"name":"MQ","_id":"cjfowdc0m000r9t9chzgtqhoz"},{"name":"DataStructure","_id":"cjfowdc0n000v9t9cqn4zutp2"},{"name":"HashMap","_id":"cjfowdc0o000z9t9cs93ey3wp"},{"name":"RocketMQ","_id":"cjfowdc0s00189t9cq6ophj4i"},{"name":"目标驱动","_id":"cjfowdc0y001m9t9cx20l536b"},{"name":"时间管理","_id":"cjfowdc0z001r9t9c8ddx61l5"},{"name":"分布式","_id":"cjfowdc10001w9t9cihkc7j0n"},{"name":"存储","_id":"cjfowdc1100219t9cicw2k6ls"}]}}