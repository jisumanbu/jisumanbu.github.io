<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



















  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.6',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  

<meta name="description" content="翻译自How does a HashMap work in JAVA - Coding Geek.欢迎指正错误。  绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashM">
<meta name="keywords" content="DataStructure,HashMap">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap的工作原理【译文】">
<meta property="og:url" content="http://www.bbetterman.com/2018/03/15/HashMap的工作原理/index.html">
<meta property="og:site_name" content="极速漫步">
<meta property="og:description" content="翻译自How does a HashMap work in JAVA - Coding Geek.欢迎指正错误。  绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashM">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://www.bbetterman.com/images/internal_storage_java_hashmap.jpg">
<meta property="og:updated_time" content="2018-03-30T03:12:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HashMap的工作原理【译文】">
<meta name="twitter:description" content="翻译自How does a HashMap work in JAVA - Coding Geek.欢迎指正错误。  绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashM">
<meta name="twitter:image" content="http://www.bbetterman.com/images/internal_storage_java_hashmap.jpg">






  <link rel="canonical" href="http://www.bbetterman.com/2018/03/15/HashMap的工作原理/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HashMap的工作原理【译文】 | 极速漫步</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">极速漫步</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="accessibility.nav_toggle">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
    </ul>
  

  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.bbetterman.com/2018/03/15/HashMap的工作原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jisumanbu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/422.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="极速漫步">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HashMap的工作原理【译文】</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T00:00:00+08:00">2018-03-15</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DataStructure/" itemprop="url" rel="index"><span itemprop="name">DataStructure</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">20k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">0:20</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>翻译自<a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="noopener">How does a HashMap work in JAVA - Coding Geek</a>.<br>欢迎指正错误。</p>
</blockquote>
<p>绝大多数JAVA开发者无时无刻不在使用Maps，特别是HashMaps。HashMap提供了即简单又强大的存储和获取数据的方式。但是又有多少人了解Hashmap的内部运行机制呢？<br>最近一段时间，为了深入了解HashMap这一重要的数据结构我阅读了绝大部分java.util.HashMap的源码， 先是基于java 7然后java 8。<br>在这篇博文里，我将为大家展示HashMap的实现原理，在java 8中的新特性在使用中要注意的关于性能和内存的问题，以及一些常见问题。</p>
<h6 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h6><blockquote>
<ol>
<li>内部存储</li>
<li>自适应大小</li>
<li>线程安全</li>
<li>Key的不可变性</li>
<li>JAVA 8中的提升</li>
<li>内存负载<ol>
<li>JAVA 7</li>
<li>JAVA 8<br>7 性能问题</li>
<li>Skewed HashMap vs well balanced HashMap</li>
<li>自适应大小带来的开销<br>8 总结</li>
</ol>
</li>
</ol>
</blockquote>
<a id="more"></a>
<h3 id="Internal-storage"><a href="#Internal-storage" class="headerlink" title="Internal storage"></a>Internal storage</h3><p>HashMap的接口是Map&lt;K,V&gt;，这个接口的主要方法有：</p>
<blockquote>
<ul>
<li>V put(K key, V value)</li>
<li>V get(Object key)</li>
<li>V remove(Object key)</li>
<li>Boolean containsKey(Object key)</li>
</ul>
</blockquote>
<p>HashMap真正存储数据的地方是其内部类：Entry&lt;K, V&gt;, 就是一个简单的键值对外加两个property：</p>
<blockquote>
<ul>
<li>指向另一个Entry的引用，从而使HashMap可以像LinkedList一样存储多个实体</li>
<li>key的hash值，从而避免每次使用时都要重复计算其hash值</li>
</ul>
</blockquote>
<p>下面是Entry在JAVA 7中的部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">int</span> hash;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>HashMap将数据存储在多个链表中（也称为<strong>分桶</strong>或分箱），所有的链表又都保存在一个Entry数组中（数组的默认容量为<strong>16</strong>）。</p>
<p>The following picture shows the inner storage<br>of a HashMap instance with an array of nullable entries.<br>Each Entry can link to another Entry to form a linked list.<br>下面这张图展示了一个HashMap实例的内部存储结构 - 一个支持null节点的数组。<br><img src="/images/internal_storage_java_hashmap.jpg" alt="internal_storage"></p>
<p>All the keys with the same hash value are put in the same linked list (bucket). Keys with different hash values can end-up in the same bucket.</p>
<p>When a user calls put(K key, V value) or get(Object key), the function computes the index of the bucket in which the Entry should be. Then, the function iterates through the list to look for the Entry that has the same key (using the equals() function of the key).</p>
<p>In the case of the get(), the function returns the value associated with the entry (if the entry exists).</p>
<p>In the case of the put(K key, V value), if the entry exists the function replaces it with the new value otherwise it creates a new entry (from the key and value in arguments) at the head of the singly linked list.</p>
<p>This index of the bucket (linked list) is generated in 3 steps by the map:</p>
<p>It first gets the hashcode of the key.<br>It rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array<br>It takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.<br>Here is the JAVA 7 and 8 source code that deals with the index:</p>
<p>// the “rehash” function in JAVA 7 that takes the hashcode of the key<br>static int hash(int h) {<br>    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);<br>    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);<br>}<br>// the “rehash” function in JAVA 8 that directly takes the key<br>static final int hash(Object key) {<br>    int h;<br>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);<br>    }<br>// the function that returns the index from the rehashed hash<br>static int indexFor(int h, int length) {<br>    return h &amp; (length-1);<br>}<br>In order to work efficiently, the size of the inner array needs to be a power of 2, let’s see why.</p>
<p>Imagine the array size is 17, the mask value is going to be 16 (size -1). The binary representation of 16 is 0…010000, so for any hash value H the index generated with the bitwise formula “H AND 16” is going to be either 16 or 0. This means that the array of size 17 will only be used for 2 buckets: the one at index 0 and the one at index 16, not very efficient…</p>
<p>But, if you now take a size that is a power of 2 like 16, the bitwise index formula is “H AND 15”. The binary representation of 15 is 0…001111 so the index formula can output values from 0 to 15 and the array of size 16 is fully used. For example:</p>
<p>if H = 952 , its binary representation is 0..01110111000, the associated index is 0…01000 = 8<br>if H = 1576 its binary representation is 0..011000101000, the associated index is  0…01000 = 8<br>if H = 12356146, its binary representation is 0..0101111001000101000110010, the associated index is 0…00010 = 2<br>if H = 59843, its binary representation is 0..01110100111000011, the associated index is 0…00011 = 3</p>
<p>This is why the array size is a power of two. This mechanism is transparent for the developer: if he chooses a HashMap with a size of 37, the Map will automatically choose the next power of 2 after 37 (64) for the size of its inner array.</p>
<p>Auto resizing<br>After getting the index, the function (get, put or remove) visits/iterates the associated linked list to see if there is an existing Entry for the given key. Without modification, this mechanism could lead to performance issues because the function needs to iterate through the entire list to see if the entry exists. Imagine that the size of the inner array is the default value (16) and you need to store 2 millions values. In the best case scenario, each linked list will have a size of 125 000 entries (2/16 millions). So, each get(), remove() and put() will lead to 125 000 iterations/operations. To avoid this case, the HashMap has the ability to increase its inner array in order to keep very short linked lists.</p>
<p>When you create a HashMap, you can specify an initial size and a loadFactor with the following constructor:</p>
<p>public HashMap(int initialCapacity, float loadFactor)<br>If you don’t specify arguments, the default initialCapacity is 16 and the default loadFactor is 0.75. The initialCapacity represents to the size of the inner array of linked lists.</p>
<p>Each time you add a new key/value in your Map with put(…), the function checks if it needs to increase the capacity of the inner array. In order to do that, the map stores 2 data:</p>
<p>The size of the map: it represents the number of entries in the HashMap. This value is updated each time an Entry is added or removed.<br>A threshold: it’s equal to (capacity of the inner array) * loadFactor and it is refreshed after each resize of the inner array<br>Before adding the new Entry, put(…) checks if size &gt; threshold and if it the case it recreates a new array with a doubled size. Since the size of the new array has changed, the indexing function (which returns the bitwise operation “hash(key) AND (sizeOfArray-1)”) changes. So, the resizing of the array creates twice more buckets (i.e. linked lists) and redistributes all the existing entries into the buckets (the old ones and the newly created).</p>
<p>This aim of this resize operation is to decrease the size of the linked lists so that the time cost of put(), remove() and get() methods stays low. All entries whose keys have the same hash will stay in the same bucket after the resizing. But, 2 entries with different hash keys that were in the same bucket before might not be in the same bucket after the transformation.</p>
<p>resizing_of_java_hashmap</p>
<p>The picture shows a representation before and after the resizing of the inner array. Before the increase, in order to get Entry E, the map had to iterate through a list of 5 elements. After the resizing, the same get() just iterates through a linked list of 2 elements, the get() is 2 times faster after the resizing !</p>
<p>Note: the HashMap only increases the size of the inner array, it doesn’t provide a way to decrease it.</p>
<p>Thread Safety<br>If you already know HashMaps, you know that is not threads safe, but why? For example imagine that you have a Writer thread that puts only new data into the Map and a Reader thread that reads data from the Map, why shouldn’t it work?</p>
<p>Because during the auto-resizing mechanism, if a thread tries to put or get an object, the map might use the old index value and won’t find the new bucket in which the entry is.</p>
<p>The worst case scenario is when 2 threads put a data at the same time and the 2 put() calls resize the Map at the same time. Since both threads modify the linked lists at the same time, the Map might end up with an inner-loop in one of its linked lists. If you tries to get a data in the list with an inner loop, the get() will never end.</p>
<p>The HashTable implementation is a thread safe implementation that prevents from this situation. But, since all the CRUD methods are synchronized this implementation is very slow. For example, if thread 1 calls get(key1), thread 2 calls get(key2) and thread 3 calls get(key3), only one thread at a time will be able to get its value whereas the 3 of them could access the data at the same time.</p>
<p>A smarter implementation of a thread safe HashMap exists since JAVA 5: the ConcurrentHashMap. Only the buckets are synchronized so multiples threads can get(), remove() or put() data at the same time if it doesn’t imply accessing the same bucket or resizing the inner array. It’s better to use this implementation in a multithreaded application.</p>
<p>Key immutability<br>Why Strings and Integers are a good implementation of keys for HashMap? Mostly because they are immutable! If you choose to create your own Key class and don’t make it immutable, you might lose data inside the HashMap.</p>
<p>Look at the following use case:</p>
<p>You have a key that has an inner value “1”<br>You put an object in the HashMap with this key<br>The HashMap generates a hash from the hashcode of the Key (so from “1”)<br>The Map  stores this hash in the newly created Entry<br>You modify the inner value of the key to “2”<br>The hash value of the key is modified but the HashMap doesn’t know it (because the old hash value is stored)<br>You try to get your object with your modified key<br>The map computes the new hash of your key (so from “2”) to find in which linked list (bucket) the entry is<br>Case 1: Since you modified your key, the map tries to find the entry in the wrong bucket and doesn’t find it<br> Case 2: Luckily, the modified key generates the same bucket as the old key. The map then iterates through the linked list to find the entry with the same key. But to find the key, the map first compares the hash values and then calls the equals() comparison. Since your modified key doesn’t have the same hash as the old hash value (stored in the entry), the map won’t find the entry in the linked-list.<br>Here is a concrete example in Java. I put 2 key-value pairs in my Map, I modify the first key and then try to get the 2 values. Only the second value is returned from the map, the first value is “lost” in the HashMap:</p>
<p>public class MutableKeyTest {</p>
<pre><code>public static void main(String[] args) {

    class MyKey {
        Integer i;

        public void setI(Integer i) {
            this.i = i;
        }

        public MyKey(Integer i) {
            this.i = i;
        }

        @Override
        public int hashCode() {
            return i;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof MyKey) {
                return i.equals(((MyKey) obj).i);
            } else
                return false;
        }

    }

    Map&lt;MyKey, String&gt; myMap = new HashMap&lt;&gt;();
    MyKey key1 = new MyKey(1);
    MyKey key2 = new MyKey(2);

    myMap.put(key1, &quot;test &quot; + 1);
    myMap.put(key2, &quot;test &quot; + 2);

    // modifying key1
    key1.setI(3);

    String test1 = myMap.get(key1);
    String test2 = myMap.get(key2);

    System.out.println(&quot;test1= &quot; + test1 + &quot; test2=&quot; + test2);

}
</code></pre><p>}<br>The output is: “test1= null test2=test 2”. As expected, the Map wasn’t able to retrieve the string 1 with the modified key 1.</p>
<p>JAVA 8 improvements<br>The inner representation of the HashMap has changed a lot in JAVA 8. Indeed, the implementation in JAVA 7 takes 1k lines of code whereas the implementation in JAVA 8 takes 2k lines. Most of what I’ve said previously is true except the linked lists of entries. In JAVA8, you still have an array but it now stores Nodes that contains the exact same information as Entries and therefore are also linked lists:</p>
<p>Here is a part of the Node implementation in JAVA 8:</p>
<p>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>     final int hash;<br>     final K key;<br>     V value;<br>     Node&lt;K,V&gt; next;<br>So what’s the big difference with JAVA 7? Well, Nodes can be extended to TreeNodes. A TreeNode is a red-black tree structure that stores really more information so that it can add, delete or get an element in O(log(n)).</p>
<p>FYI, here is the exhaustive list of the data stored inside a TreeNode</p>
<p>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {<br>    final int hash; // inherited from Node&lt;K,V&gt;<br>    final K key; // inherited from Node&lt;K,V&gt;<br>    V value; // inherited from Node&lt;K,V&gt;<br>    Node&lt;K,V&gt; next; // inherited from Node&lt;K,V&gt;<br>    Entry&lt;K,V&gt; before, after;// inherited from LinkedHashMap.Entry&lt;K,V&gt;<br>    TreeNode&lt;K,V&gt; parent;<br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;<br>    boolean red;<br>Red black trees are self-balancing binary search trees. Their inner mechanisms ensure that their length is always in log(n) despite new adds or removes of nodes. The main advantage to use those trees is in a case where many data are in the same index (bucket) of the inner table, the search in a tree will cost O(log(n)) whereas it would have cost O(n) with a linked list.</p>
<p>As you see, the tree takes really more space than the linked list (we’ll speak about it in the next part).</p>
<p>By inheritance, the inner table can contain both Node (linked list ) and TreeNode (red-black tree). Oracle decided to use both data structures with the following rules:<br>– If for a given index (bucket) in the inner table there are more than 8 nodes, the linked list is transformed into a red black tree<br>– If for a given index (bucket) in the inner table there are less than 6 nodes, the tree is transformed into a linked list</p>
<p>internal_storage_java8_hashmap</p>
<p>This picture shows an inner array of a JAVA 8 HashMap with both trees (at bucket 0) and linked lists (at bucket 1,2 and 3). Bucket 0 is a Tree because it has more than 8 nodes.</p>
<p>Memory overhead<br>JAVA 7</p>
<p>The use of a HashMap comes at a cost in terms of memory. In JAVA 7, a HashMap wraps key-value pairs in Entries. An entry has:</p>
<p>a reference to a next entry<br>a precomputed hash (integer)<br>a reference to the key<br>a reference to the value<br>Moreover, a JAVA 7 HashMap uses an inner array of Entry. Assuming a JAVA 7 HashMap contains N elements and its inner array has a capacity CAPACITY, the extra memory cost is approximately:</p>
<p>sizeOf(integer)<em> N + sizeOf(reference)</em> (3*N+C)</p>
<p>Where:</p>
<p>the size of an integer depends equals 4 bytes<br>the size of a reference depends on the JVM/OS/Processor but is often 4 bytes.<br>Which means that the overhead is often 16 <em> N + 4 </em> CAPACITY bytes</p>
<p>Reminder: after an auto-resizing of the Map, the  CAPACITY  of the inner array equals the next power of two after N.</p>
<p>Note: Since JAVA 7, the HashMap class has a lazy init. That means that even if you allocate a HashMap, the inner array of entry (that costs 4 * CAPACITY bytes) won’t be allocated in memory until the first use of the put() method.</p>
<p>JAVA 8</p>
<p>With the JAVA 8 implementation, it becomes a little bit complicated to get the memory usage because a Node can contain the same data as an Entry or the same data plus 6 references and a Boolean (if it’s a TreeNode).</p>
<p>If the all the nodes are only Nodes, the memory consumption of the JAVA 8 HashMap is the same as the JAVA 7 HashMap.</p>
<p>If the all the nodes are TreeNodes, the memory consumption of a JAVA 8 HashMap becomes:</p>
<p>N <em> sizeOf(integer) + N </em> sizeOf(boolean) + sizeOf(reference)<em> (9</em>N+CAPACITY )</p>
<p>In most standards JVM, it’s equal to 44 <em> N + 4 </em> CAPACITY bytes</p>
<p>Performance issues<br>Skewed HashMap vs well balanced HashMap</p>
<p>In the best case scenario, the get() and put() methods have a O(1) cost in time complexity. But, if you don’t take care of the hash function of the key, you might end up with very slow put() and get() calls. The good performance of the put() and get depends on the repartition of the data into the different indexes of the inner array (the buckets). If the hash function of your key is ill-designed, you’ll have a skew repartition (no matter how big the capacity of the inner array is). All the put() and get() that use the biggest linked lists of entry will be slow because they’ll need to iterate the entire lists. In the worst case scenario (if most of the data are in the same buckets), you could end up with a O(n) time complexity.<br>Here is a visual example. The first picture shows a skewed HashMap and the second picture a well balanced one.</p>
<p>skewed_java_hashmap</p>
<p>In the case of this skewed HashMap the get()/put() operations on the bucket 0 are costly. Getting the Entry K will cost 6 iterations</p>
<p>well_balanced_java_hashmapIn the case of this well balanced HashMap, getting the Entry K will cost 3 iterations. Both HashMaps store the same amount of data and have the same inner array size. The only difference is the hash (of the key) function that distributes the entries in the buckets.</p>
<p>Here is an extreme example in JAVA where I create a hash function that puts all the data in the same bucket then I add 2 million elements.</p>
<p>public class Test {</p>
<pre><code>public static void main(String[] args) {

    class MyKey {
        Integer i;
        public MyKey(Integer i){
            this.i =i;
        }

        @Override
        public int hashCode() {
            return 1;
        }

        @Override
        public boolean equals(Object obj) {
        …
        }

    }
    Date begin = new Date();
    Map &lt;MyKey,String&gt; myMap= new HashMap&lt;&gt;(2_500_000,1);
    for (int i=0;i&lt;2_000_000;i++){
        myMap.put( new MyKey(i), &quot;test &quot;+i);
    }

    Date end = new Date();
    System.out.println(&quot;Duration (ms) &quot;+ (end.getTime()-begin.getTime()));
}
</code></pre><p>}<br>On my core i5-2500k @ 3.6Ghz it takes more than 45 minutes with java 8u40 (I stopped the process after 45 minutes).</p>
<p>Now, If I run the same code but this time I use the following hash function</p>
<pre><code>@Override
public int hashCode() {
    int key = 2097152-1;
    return key+2097152*i;
</code></pre><p>}<br>it takes 46 seconds, which is way better! This hash function has a better repartition than the previous one so the put() calls are faster.</p>
<p>And If I run the same code with the following hash function that provides an even better hash repartition</p>
<p>@Override<br>public int hashCode() {<br>return i;<br>}<br>it now takes 2 seconds.</p>
<p>I hope you realize how important the hash function is. If a ran the same test on JAVA 7, the results would have been worse for the first and second cases (since the time complexity of put is O(n) in JAVA 7 vs O(log(n)) in JAVA 8)</p>
<p>When using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.</p>
<p>Resizing overhead</p>
<p>If you need to store a lot of data, you should create your HashMap with an initial capacity close to your expected volume.</p>
<p>If you don’t do that, the Map will take the default size of 16 with a factorLoad of 0.75. The 11 first put() will be very fast but the 12th (16<em>0.75) will recreate a new inner array (with its associated linked lists/trees) with a new capacity of 32. The 13th to 23th will be fast but the 24th (32</em>0.75) will recreate (again) a costly new representation that doubles the size of the inner array. The internal resizing operation will appear at the 48th, 96th,192th, … call of put(). At low volume the full recreation of the inner array is fast but at high volume it can takes seconds to minutes. By initially setting your expected size, you can avoid these costly operations.</p>
<p>But there is a drawback: if you set a very high array size like 2^28 whereas you’re only using 2^26 buckets in your array, you will waste a lot of memory (approximately 2^30 bytes in this case).</p>
<p>Conclusion<br>For simple use cases, you don’t need to know how HashMaps work since you won’t see the difference between a O(1) and a O(n) or O(log(n)) operation. But it’s always better to understand the underlaying mecanism of one of the most used data structures. Moreover, for a java developer position it’s a typical interview question.</p>
<p>At high volume it becomes important to know how it works and to understand the importance of the hash function of the key.</p>
<p>I hope this article helped you to have a deep understanding of the HashMap implementation.</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DataStructure/" rel="tag"># DataStructure</a>
          
            <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/15/redisInAction/" rel="next" title="Redis实战（Redis IN ACTION）">
                <i class="fa fa-chevron-left"></i> Redis实战（Redis IN ACTION）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/17/以企业的方式经营家庭/" rel="prev" title="以企业的方式经营家庭">
                以企业的方式经营家庭 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/422.jpg"
                alt="jisumanbu" />
            
              <p class="site-author-name" itemprop="name">jisumanbu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/jisumanbu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:jisumanbu@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-6"><a class="nav-link" href="#Contents"><span class="nav-number">1.</span> <span class="nav-text">Contents</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Internal-storage"><span class="nav-number"></span> <span class="nav-text">Internal storage</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jisumanbu</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">29k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点总阅读时长">0:29</span>
  
</div>




  <div style="display:none" class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span style="display:none" class="post-meta-divider">|</span>



  <div style="display:none" class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.6</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.6"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.6"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.6"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

</body>
</html>
